= Hello! =

Shoes is a tiny graphics toolkit. It's simple and straightforward. Shoes was
born to be easy! Really, it was made for absolute beginners. There's really
nothing to it.

You see, the trivial Shoes program can be just one line:

{{{
 #!ruby
 Shoes.app { button("Click me!") { alert("Good job.") } }
}}}

Shoes programs are written in a language called Ruby. When Shoes is handed
this simple line of Ruby code, a window appears with a button inside reading
"Click me!" When the button is clicked, a message pops up.

On Linux, here's how this might look: !{:margin_left => 100}man-shot1.png!

While lots of Shoes apps are graphical games and art programs, you can also layout text and edit controls easily. !{:margin_left => 40}shoes-manual-apps.png!

And, ideally, Shoes programs will run on any of the major platforms out there.
Microsoft Windows, Apple's Mac OS X, Linux and many others.

^So, welcome to Shoes' built-in manual. This manual is a Shoes program itself!^

== Introducing Shoes ==

How does Shoes look on OS X and Windows? Does it really look okay? Is it all
ugly and awkward? Is it so watered down trying to do everything that nothing
looks right? 

Well, before getting into the stuff about installing and running Shoes, time to
just check out some screenshots, to give you an idea of what you can do.

==== Mac OS X ====

Shoes runs on Apple Mac OS X 10.9 Mavericks. Shoes no longer runs on PPC Macs
or 32 bit Macs because Apple doesn't think they exist. Shoes may run on earlier 
64 bit Intel versions of OSX like 10.8 but you should not depend on that. 

!man-look-mavericks.png!

Don't worry. You can make things as pretty as you care to. That particular app
is not worth the effort to prettify. It's utilitarian, with a single purpose, and odds are only
the author cares about it. It's a very small program - only 77 lines, and 3
lines are about how OSX might not work - clearly it does. 

It does show one reason we love Shoes. You can do clever and pretty things and you
can write little programs that maybe only you need and it's easier than any
other method.

==== Windows ====

Shoes runs on all versions of '''Microsoft Windows XP''', '''Windows Vista''',
'''Windows 7''', and anything else '''Windows 2000''' compatible. 
!man-look-vista.png!

Above is pictured the `simple-clock.rb` sample running on Windows Vista. This
example draws ovals and lines to build the clock, which is animated to
repaint itself several times each second.

Notice the text on the top of the app, showing the current time. Shoes has the
skills to layout words using any color, bold, italics, underlines, and supports
loading fonts from a file.

==== Linux ====

Here's a screenshot of the `simple-downloader.rb` sample running on '''Ubuntu
Linux'''. !man-look-ubuntu.png!

Notice the buttons and progress bars. These types of controls look different on
OS X and Windows. The text and links would look the same, though.

Shapes, text, images and videos all look the same on every platform. However,
native controls (like edit lines and edit boxes) will match the look of the
window theme. Shoes will try to keep native controls all within the size you
give them, only the look will vary.

== Installing Shoes ==

Okay, on to installing Shoes. I'm sure you're wondering: do I need to install
Ruby? Do I need to unzip anything? What commands do I need to type?

Nope. You don't need Ruby. You don't need WinZip. Nothing to type.

On most systems, starting Shoes is just a matter of running the installer and
clicking the Shoes icon. Shoes comes with everything built in. We'll talk
through all the steps, though, just to be clear about it.

==== Step 1: Installing Shoes ====

You'll want to visit [[http://shoesrb.com/ the site of Shoes]] to download
the Shoes installer. Usually, you'll just want one of the installers on the
downloads page of the site. !man-builds1.png!

Here's how to run the installer:

 * On '''Mac OS X''', you'll have a file ending with '''.tbz''' in the Downloads folder. Double-click this file and a file should appear with a '''Shoes''' icon. You may be asked to trust the download package. Drag the Shoes icon into the '''Applications''' folder. !man-builds2.png!
 * On '''Windows''', you'll download a '''.exe''' file. Double-click this file and follow the instructions. !man-intro-exe.png!
 * On '''Linux''', make the '''.install''' file executable with '''chmod +x Shoes-3.2-stuff.install''' and run that, '''./Shoes-3.2-stuff.install''' It will ask for the admin password to create a menu entry.

==== Step 2: Start a New Text File ====

Shoes programs are just plain text files ending with a '''.rb''' extension.

Here are a few ways to create a blank text file:

 * On '''Mac OS X''', visit your '''Applications''' folder and double-click on the '''TextEdit''' app. A blank editor window should come up. Now, go to the '''Format''' menu and select the '''Make Plain Text''' option. Okay, you're all set! !man-editor-osx.png!
 * On '''Windows''', go to the Start menu. Select '''All Programs''', then '''Accessories''', then '''Notepad'''. !man-editor-notepad.png!
 * On '''Linux''', most distros come with '''gedit'''. You might try running that. Or, if your distro is KDE-based, run '''kate'''.

Now, in your blank window, type in the following:

{{{
 Shoes.app do
   background "#DFA"
   para "Welcome to Shoes"
 end
}}}

Save to your desktop or home directory as `welcome.rb`.

==== Step 3: Run It! Go Shoes! ====

There are several ways to run a Shoes program. The easiest is from the 'splash' screen.
We're going to use the '''Open an App''' link to browse to where you stored
`welcome.rb`.  !man-splash.png!

To run your program, start Shoes:

 * On '''Mac OS X''', visit your '''Applications''' folder again. This time, double-click the '''Shoes''' icon in that folder. You should see the splash screen above. 
 * On '''Windows''', get to the Start menu. Go into '''All Programs''', then '''Shoes''', then '''Shoes'''. You should see the splash screen above.
 * On '''Linux''', look for the Shoes icon in the menus Programming, Education, or Others. Select it. You should see the splash screen above.

So, not much of a program yet. But it's something! You've got the knack of it, at least!

==== What Can You Make With Shoes? ====

Well, you can make windowing applications. But Shoes is inspired by the web, so
applications tend to use images and text layout rather than a lot of widgets.
For example, Shoes doesn't come with tabbed controls or toolbars. Shoes is a
''tiny'' toolkit, remember?

Still, Shoes does have a few widgets like buttons and edit boxes. And many
missing elements (like tabbed controls or toolbars) can be simulated with
images.

Shoes is written in part thanks to a very good art engine called Cairo, which
is used for drawing with shapes and colors. In this way, Shoes is inspired by
NodeBox and Processing, two very good languages for drawing animated graphics.

== The Rules of Shoes ==

Time to stop guessing how Shoes works. Some of the tricky things will come
back to haunt you. I've boiled down the central rules to Shoes. These are the
things you MUST know to really make it all work.

These are general rules found throughout Shoes. While Shoes has an overall
philosophy of simplicity and clarity, there are a few points that need to be
studied and remembered.

==== Shoes Tricky Blocks ====

Okay, this is absolutely crucial. Shoes does a trick with blocks. This trick
makes everything easier to read. But it also can make blocks harder to use
once you're in deep.

'''Let's take a normal Ruby block:'''

{{{
 ary = ['potion', 'swords', 'shields']
 ary.each do |item|
   puts item
 end
}}}

In Shoes, these sorts of blocks work the same. This block above loops through
the array and stores each object in the `item` variable. The `item` variable
disappears (goes out of scope) when the block ends.

One other thing to keep in mind is that `self` stays the same inside normal
Ruby blocks. Whatever `self` was before the call to `each`, it is the same
inside the `each` block.

'''Both of these things are also true for most Shoes blocks.'''

{{{
 Shoes.app do
   stack do
     para "First"
     para "Second"
     para "Third"
   end
 end
}}}

Here we have two blocks.  The first block is sent to `Shoes.app`.  This `app`
block changes `self`.

The other block is the `stack` block.  That block does NOT change self.

'''For what reason does the `app` block change self?'''  Let's start by
spelling out that last example completely.

{{{
 Shoes.app do
   self.stack do
     self.para "First"
     self.para "Second"
     self.para "Third"
   end
 end
}}}

All of the `self`s in the above example are the App object.  Shoes uses Ruby's
`instance_eval` to change self inside the `app` block.  So the method calls to
`stack` and `para` get sent to the app.

'''This also is why you can use instance variables throughout a Shoes app:'''

{{{
 Shoes.app do
   @s = stack do
     @p1 = para "First"
     @p2 = para "Second"
     @p3 = para "Third"
   end
 end
}}}

These instance variables will all end up inside the App object.

'''Whenever you create a new window, `self` is also changed.'''  So, this means the [[Element.window]] and [[Element.dialog]] methods, in addition to Shoes.app.

{{{
 Shoes.app :title => "MAIN" do
   para self
   button "Spawn" do
     window :title => "CHILD" do
       para self
     end
   end
 end
}}}

==== Block Redirection ====

The `stack` block is a different story, though.  It doesn't change `self` and
it's basically a regular block.

'''But there's a trick:''' when you attach a `stack` and give it a block, the
App object places that stack in its memory.  The stack gets popped off when the
block ends.  So all drawing inside the block gets '''redirected''' from the
App's top slot to the new stack.

So those three `para`s will get drawn on the `stack`, even though they actually
get sent to the App object first.

{{{
 Shoes.app do
   stack do
     para "First"
     para "Second"
     para "Third"
   end
 end
}}}

A bit tricky, you see?  This can bite you even if you know about it.

One way it'll get you is if you try to edit a stack somewhere else in your
program, outside the `app` block.

Like let's say you pass around a stack object.  And you have a class that edits
that object.

{{{
 class Messenger
   def initialize(stack)
     @stack = stack
   end
   def add(msg)
     @stack.append do
       para msg
     end
   end
 end
}}}

So, let's assume you pass the stack object into your Messenger class when the
app starts.  And, later, when a message comes in, the `add` method gets used to
append a paragraph to that stack.  Should work, right?

Nope, it won't work.  The `para` method won't be found.  The App object isn't
around any more.  And it's the one with the `para` method.

Fortunately, each Shoes object has an `app` method that will let you reopen the
App object so you can do somefurther editing.

{{{
 class Messenger
   def initialize(stack)
     @stack = stack
   end
   def add(msg)
     @stack.app do
       @stack.append do
         para msg
       end
     end
   end
 end
}}}

As you can imagine, the `app` object changes `self` to the App object.

So the rules here are:

1. '''Methods named "app" or which create new windows alter `self` to the App
object.'''[[BR]](This is true for both Shoes.app and Slot.app, as well as
[[Element.window]] and [[Element.dialog]].)[[BR]]
2. '''Blocks attached to stacks, flows or any manipulation method (such as
append) do not change self. Instead, they pop the slot on to the app's editing
stack.'''

==== Careful With Fixed Heights ====

Fixed widths on slots are great so you can split the window into columns.

{{{
 Shoes.app do
   flow do
     stack :width => 200 do
       caption "Column one"
       para "is 200 pixels wide"
     end
     stack :width => -200 do
       caption "Column two"
       para "is 100% minus 200 pixels wide"
     end
   end
 end
}}}

Fixed heights on slots should be less common.  Usually you want your text and
images to just flow down the window as far as they can.  Height usually happens
naturally.

The important thing here is that fixed heights actually force slots to behave
differently.  To be sure that the end of the slot is chopped off perfectly, the
slot becomes a '''nested window'''.  A new layer is created by the operating
system to keep the slot in a fixed square.

One difference between normal slots and nested window slots is that the latter
can have scrollbars.

{{{
 Shoes.app do
   stack :width => 200, :height => 200, :scroll => true do
     background "#DFA"
     100.times do |i|
       para "Paragraph No. #{i}"
     end
   end
 end
}}}

These nested windows require more memory.  They tax the application a bit more.
So if you're experiencing some slowness with hundreds of fixed-height slots,
try a different approach.

==== Image and Shape Blocks ====

Most beginners start littering the window with shapes.  It's just easier to
throw all your rectangles and ovals in a slot.

'''However, bear in mind that Shoes will create objects for all those
shapes!'''

{{{
 Shoes.app do
   fill black(0.1)
   100.times do |i|
     oval i, i, i * 2
   end
 end
}}}

In this example, one-hundred Oval objects are created.  This isn't too bad.
But things would be slimmer if we made these into a single shape.

{{{
 Shoes.app do
   fill black(0.1)
   shape do
     100.times do |i|
       oval i, i, i * 2
     end
   end
 end
}}}

Oh, wait.  The ovals aren't filled in this time!  That's because the ovals have
been combined into a single huge shape.  And Shoes isn't sure where to fill in
this case.

So you usually only want to combine into a single shape when you're dealing
strictly with outlines.

Another option is to combine all those ovals into a single image.

{{{
 Shoes.app do
   fill black(0.1)
   image 300, 300 do
     100.times do |i|
       oval i, i, i * 2
     end
   end
 end
}}}

There we go!  The ovals are all combined into a single 300 x 300 pixel image.
In this case, storing that image in memory might be much bigger than having
one-hundred ovals around.  But when you're dealing with thousands of shapes,
the image block can be cheaper.

The point is: it's easy to group shapes together into image or shape blocks, so
give it a try if you're looking to gain some speed.  Shape blocks particularly
will save you some memory and speed.

==== UTF-8 Everywhere ====

Ruby is now very Unicode aware.  And UTF-8 is a type of Unicode.  (See
[[http://en.wikipedia.org/wiki/UTF-8 Wikipedia]] for a full explanation of
UTF-8.)

However, UTF-8 is common on the web.  And lots of different platforms support
it.  So to cut down on the amount of conversion that Shoes has to do, Shoes
expects all strings to be in UTF-8 format.

This is great because you can show a myriad of languages (Russian, Japanese,
Spanish, English) using UTF-8 in Shoes.  Just be sure that your text editor
uses UTF-8!

To illustrate:

{{{
 Shoes.app do
   stack :margin => 10 do
     @edit = edit_box :width => 1.0 do
       @para.text = @edit.text
     end
     @para = para ""
   end
 end
}}}

This app will copy anything you paste into the edit box and display it in a
Shoes paragraph.  You can try copying some foreign text (such as Greek or
Japanese) into this box to see how it displays.

This is a good test because it proves that the edit box gives back UTF-8
characters.  And the paragraph can be set to any UTF-8 characters.

'''Important note:''' if some UTF-8 characters don't display for you, you will
need to change the paragraph's font.  This is especially common on OS X.

So, a good Japanese font on OS X is '''AppleGothic''' and on Windows is '''MS
UI Gothic'''.

{{{
 Shoes.app do
   para "てすと (te-su-to)", :font => case RUBY_PLATFORM
    when /mingw/; "MS UI Gothic"
    when /darwin/; "AppleGothic, Arial"
    else "Arial"
    end
 end
}}}

Again, anything which takes a string in Shoes will need a UTF-8 string.  Edit
boxes, edit lines, list boxes, window titles and text blocks all take UTF-8. If
you give a string with bad characters in it, an error will show up in the
console.

==== App and Its Scope ====

Modern Shoes uses TOPLEVEL_BINDING.  Binding is not an easy concept so anything you
read here needs a large grain of salt. Any method or class defined before Ruby 
reads the Shoe.app {block} belongs to Ruby 'main' binding and anyhing defined
inside the Shoes.app {block} belongs to that app binding. Inside the app binding you 
can call on those `main` bound methods but those methods can't (easily) invoke methods in
a Shoes.app binding. Confused? Join the crowd.

Each Shoes.app {} or Window {} you create in your scripts gets a different `binding`
so the variable "my_button" in one window is a different object from a variable "my_button" in 
the other window (for example). Different windows, different bindings for the same name.

This isolates one window from another. Some consider this a `good thing`. It's not going
to change however,  so some say `live with it` [[https://github.com/Shoes3/shoes3/wiki/Poking-in-Shoes.app Poking in Shoes]] explore how to use APP[] and app but it only a starter course
in a very long menu.

For complex, multi-window Shoes apps that need to share some things and not
others it's still unknown best practices. There might be more information
in [[Structuring]] or on the wiki.


= Shoes =

Shoes is all about drawing windows and the stuff inside those windows.  Let's
focus on the window itself, for now.  The other sections [[Slots]] and
[[Elements]] cover everything that goes inside the window.

For here on, the manual reads more like a dictionary. Each page is mostly a
list of methods you can use for each topic covered. The idea is to be very
thorough and clear about everything.

So, if you've hit this far in the manual and you're still hazy about getting
started, you should probably either go back to the [[Hello! beginning]] of the
manual. Or you could try [[https://github.com/downloads/shoes/shoes/nks.pdf Nobody Knows Shoes]], the beginner's leaflet PDF.

==== Finding Your Way ====

This section covers:

 * [[Built-in Built-in methods]] - general methods available anywhere in a Shoes program.
 * [[App The App window]] - methods found attached to every main Shoes window.
 * [[Styles The Styles Master List]] - a complete list of every style in Shoes.
 * [[Classes The Classes list]] - a chart showing what Shoes classes subclass what.
 * [[Colors The Colors list]] - a chart of all built-in colors and the [[Built-in.rgb]] numbers for each.
 * [[Special Specialized methods]] - oddities that don't really fit App or Built-in

If you find yourself paging around a lot and not finding something, give the
[[Search]] page a try. It's the quickest way to get around.

After this general reference, there are two other more specific sections:

 * [[Slots]] - covering [[Element.stack]] and [[Element.flow]], the two types of slots.
 * [[Elements]] - documentation for all the buttons, shapes, images, and so on.

Two really important pages in there are the [[Element Element Creation]] page
(which lists all the elements you can add) and the [[Common Common Methods]]
page (which lists methods you'll find on any slot or element.)

== Built-in Methods ==

These methods can be used anywhere throughout Shoes programs.

All of these commands are unusual because you don't attach them with a dot.
'''Every other method in this manual must be attached to an object with a dot.'''
But these are built-in methods (also called: Kernel methods.) Which means no dot!

A common one is `alert`:

{{{
 #!ruby
 alert "No dots in sight"
}}}

Compare that to the method `reverse`, which isn't a Kernel method and is only
available for Arrays and Strings:

{{{
 #!ruby
 "Plaster of Paris".reverse
  #=> "siraP fo retsalP"
 [:dogs, :cows, :snakes].reverse
  #=> [:snakes, :cows, :dogs]
}}}

Most Shoes methods for drawing and making buttons and so on are attached to
slots.  See the section on [[Slots]] for more.

==== Built-in Constants ====

Shoes also has a handful of built-in constants which may prove useful if you
are trying to sniff out what release of Shoes is running.

Shoes 3.2.22 introduced new constants that you should use instead of the older ones.

'''Shoes::VERSION_NUMBER''' is a string like '3.2.22'

'''Shoes::VERSION_MAJOR''' is a number, the first one of VERSION_NUMBER

'''Shoes::VERSION_MINOR''' is a number, the second one in VERSION_NUMBER

'''Shoes::VERSION_TINY''' is a number, the last in VERSION_NUMBER

'''Shoes::VERSION_NAME''' is a string with the name of the Shoes release, like 'federales'

'''Shoes::VERSION_REVISION''' is a number. Probably the count of commits but it 
could have been set to some other number by the builder.

'''Shoes::VERSION_DATE''' is a string. It's the build date.

'''Shoes::VERSION_PLATFORM''' is a string. It's probably the platform your
Shoes was built on which '''is not the same''' as '''RUBY_PLATFORM'''

'''Shoes::FONTS''' is a complete list of fonts available to the app.  This list
includes any fonts loaded by the [[Built-in.font]] method.

Deprecated constants:

Shoes::RELEASE_NAME contains a string with the name of the Shoes release.
All Shoes releases are named, starting with Curious.

Shoes::RELEASE_ID contains a number representing the Shoes release.  So,
for example, Curious is number 1, as it was the first official release.

Shoes::REVISION is the Subversion revision number for this build.



=== alert(message: a string, :title => a string or nil) » nil ===

Pops up a window containing a short message.

{{{
 #!ruby
 alert("I'm afraid I must interject!")
}}}

`:title` is optional and replaces the default "Shoes says:" with the string you provide or could be set to `nil` in which case the window won't have a title at all.

{{{
 #!ruby
 alert("I'm afraid I must interject!", :title => "Sorry but :")
}}}

{{{
 #!ruby
 alert("I'm afraid I must interject!", :title => nil)
}}}

Please use alerts sparingly, as they are incredibly annoying!  If you are using
alerts to show messages to help you debug your program, try checking out the
[[Built-in.debug]] or [[Built-in.info]] methods.

=== ask(message: a string, :title => a string or nil) » a string ===

Pops up a window and asks a question. For example, you may want to ask someone
their name.

{{{
 #!ruby
 name = ask("Please, enter your name:")
}}}

When the above script is run, the person at the computer will see a window with
a blank box for entering their name. The name will then be saved in the `name`
variable.

`:title` is optional and replace the default "Shoes asks:" with the string you provide or could be set to `nil` in which case the window won't have a title at all.
See [[Built-in.alert]] method for similar examples.

=== ask_color(title: a string) » Shoes::Color ===

Pops up a color picker window. The program will wait for a color to be picked,
then gives you back a Color object. See the `Color` help for some ways you can
use this color.

{{{
 #!ruby
 backcolor = ask_color("Pick a background")
 Shoes.app do
  background backcolor
 end
}}}

=== ask_open_file() » a string ===

Pops up an "Open file..." window. It's the standard window which shows all of
your folders and lets you select a file to open. Hands you back the name of the
file. 

{{{
 #!ruby
 filename = ask_open_file
 Shoes.app do
   para File.read(filename)
 end
}}}

You can also specify the title string the dialog displays by including a hash argument 
with 'title'. This 'title' feature is new with Shoes 3.3.3 and is also available for
ask_save_file, ask_open_folder and ask_save_folder as well as ask_open_file.

{{{
 #!ruby
 Shoes.app do
   button "open special" do
     sel = ask_open_file title: "Shoes Manual wants you to select a file"
     para "Selected: #{sel}"
   end
 end
}}}

=== ask_save_file() » a string ===

Pops up a "Save file..." window, similiar to `ask_open_file`, described
previously.

{{{
 #!ruby
 save_as = ask_save_file
}}}

=== ask_open_folder() » a string ===

Pops up an "Open folder..." window. It's the standard window which shows all of
your folders and lets you select a folder to open. Hands you back the name of
the folder.

{{{
 #!ruby
 folder = ask_open_folder
 Shoes.app do
   para Dir.entries(folder)
 end
}}}

=== ask_save_folder() » a string ===

Pops up a "Save folder..." window, similiar to `ask_open_folder`, described
previously. On OS X, this method currently behaves like an alias of
`ask_open_folder`.

{{{
 #!ruby
 save_to = ask_save_folder
}}}


=== confirm(question: a string, :title => a string or nil) » true or false ===

Pops up a yes-or-no question. If the person at the computer, clicks '''yes''',
you'll get back a `true`. If not, you'll get back `false`.

{{{
 #!ruby
 if confirm("Draw a circle?")
  Shoes.app{ oval :top => 0, :left => 0, :radius => 50 }
 end
}}}
          
`:title` is optional and replace the default "Shoes asks:" with the string you provide or could be set to `nil` in which case the window won't have a title at all.
See [[Built-in.alert]] method for similar examples.

=== debug(message: a string) » nil ===

Sends a debug message to the Shoes console.  You can bring up the Shoes console
by pressing `Alt-/` on any Shoes window (or `⌘-/` on OS X.)

{{{
 #!ruby
 debug("Running Shoes on " + RUBY_PLATFORM)
}}}

Also check out the [[Built-in.error]], [[Built-in.warn]] and [[Built-in.info]]
methods.

=== error(message: a string) » nil ===

Sends an error message to the Shoes console.  This method should only be used
to log errors.  Try the [[Built-in.debug]] method for logging messages to
yourself.

Oh, and, rather than a string, you may also hand exceptions directly to this
method and they'll be formatted appropriately.

=== Shoes.quit() ===

Stops your program. Call this anytime you want to suddenly call it quits.
It stops all the graphical things in a graceful way and eventually terminate
your program. 

=== exit() ===

This is no longer recommended as the way to quit a Shoes program. Instead 
use Shoes.quit(). Overriding the Ruby exit method has some undesired behaviour 
in some situations such as:

'''PLEASE NOTE:''' If you need to use Ruby's own `exit` method (like in a
forked Ruby process,) call `Kernel.exit`.

exit it can also confuse the debugger (the code) and you. So Shoes.quit 
is better.

=== font(message: a string) » an array of font family names ===

Loads a TrueType (or other type of font) from a file.  While TrueType is
supported by all platforms, your platform may support other types of fonts.
Shoes uses each operating system's built-in font system to make this work.

Here's a rough idea of what fonts work on which platforms:

 * Bitmap fonts (.bdf, .pcf, .snf) - Linux
 * Font resource (.fon) - Windows
 * Windows bitmap font file (.fnt) - Linux, Windows
 * PostScript OpenType font (.otf) - Mac OS X, Linux, Windows
 * Type1 multiple master (.mmm) - Windows
 * Type1 font bits (.pfb) - Linux, Windows
 * Type1 font metrics (.pfm) - Linux, Windows
 * TrueType font (.ttf) - Mac OS X, Linux, Windows
 * TrueType collection (.ttc) - Mac OS X, Linux, Windows

If the font is properly loaded, you'll get back an array of font names found in
the file.  Otherwise, `nil` is returned if no fonts were found in the file.

Also of interest: the `Shoes::FONTS` constant is a complete list of fonts
available to you on this platform.  You can check for a certain font by using
`include?`.

{{{
 if Shoes::FONTS.include? "Helvetica"
   alert "Helvetica is available on this system."
 else
   alert "You do not have the Helvetica font."
 end
}}}

If you have trouble with fonts showing up, make sure your app loads the font
before it is used.  Especially on OS X, if fonts are used before they are
loaded, the font cache will tend to ignore loaded fonts.

=== gradient(color1, color2) » Shoes::Pattern ===

Builds a linear gradient from two colors.  For each color, you may pass in a
Shoes::Color object or a string describing the color.
{{{
Shoes.app do
   fill gradient(red, green)
   oval 10, 10, 150
end
}}}

=== gray(the numbers: darkness, alpha) » Shoes::Color ===

Create a grayscale color from a level of darkness and, optionally, an alpha
level.

{{{
 black = gray(0.0)
 white = gray(1.0)
}}}

{{{
Shoes.app do
   fill gray(127)
   oval 10, 10, 150
end
}}}

=== info(message: a string) » nil ===

Logs an informational message to the user in the Shoes console.  So, where
debug messages are designed to help the program figure out what's happening,
`info` messages tell the user extra information about the program.

{{{
 #!ruby
 
 info("You just ran the info example on Shoes #{Shoes::RELEASE_NAME}.")
}}}

For example, whenever a Shy file loads, Shoes prints an informational message
in the console describing the author of the Shy and its version.

=== rgb(a series of numbers: red, green, blue, alpha) » Shoes::Color ===

Create a color from red, green and blue components.  An alpha level (indicating
transparency) can also be added, optionally.

When passing in a whole number, use values from 0 to 255.

{{{
 blueviolet = rgb(138, 43, 226)
 darkgreen = rgb(0, 100, 0)
}}}

Or, use a decimal number from 0.0 to 1.0.

{{{
 blueviolet = rgb(0.54, 0.17, 0.89)
 darkgreen = rgb(0, 0.4, 0)
}}}

This method may also be called as `Shoes.rgb`.

=== warn(message: a string) » nil ===

Logs a warning for the user.  A warning is not a catastrophic error (see
[[Built-in.error]] for that.)  It is just a notice that the program will be
changing in the future or that certain parts of the program aren't reliable
yet.

To view warnings and errors, open the Shoes console with `Alt-/` (or `⌘-/` on
OS X.)

== The App Object ==

An App is a single window running code at a URL. When you switch URLs, a new
App object is created and filled up with stacks, flows and other Shoes
elements.

The App is the window itself. Which may be closed or cleared and filled with
new elements. !{:margin_left => 100}man-app.png!

The App itself, in slot/box terminology, is a flow.  See the ''Slots'' section
for more, but this just means that any elements placed directly at the
top-level will flow.

=== Shoes.app(styles) { ... } » Shoes::App ===

Starts up a Shoes app window.  This is the starting place for making a Shoes
program.  Inside the block, you fill the window with various Shoes elements
(buttons, artwork, etc.) and, outside the block, you use the `styles` to
describe how big the window is.  Perhaps also the name of the app or if it's
resizable.

{{{
 #!ruby
 Shoes.app(:title => "White Circle",
   :width => 200, :height => 200, :resizable => false) {
     background black
     fill white
     oval :top => 20, :left => 20, :radius => 160
 }
}}}

In the case above, a small window is built.  200 pixels by 200 pixels.  It's
not resizable.  And, inside the window, two elements: a black background and a
white circle.

Once an app is created, it is added to the [[App.Shoes.APPS]] list.  If you
want an app to spawn more windows, see the [[Element.window]] method and the
[[Element.dialog]] method.

=== Shoes.APPS() » An array of Shoes::App objects ===

Builds a complete list of all the Shoes apps that are open right now.  Once an
app is closed, it is removed from the list.  Yes, you can run many apps at once
in Shoes.  It's completely encouraged.

=== clipboard() » a string ===

Returns a string containing all of the text that's on the system clipboard.
This is the global clipboard that every program on the computer cuts and pastes
into.

{{{
Shoes.app(:title => "Copy and Paste", :width => 450, :height => 250) do
   button "copy" do
      self.clipboard = "this is a Shoes string."
   end
   button "paste" do
      para clipboard()
   end
end
}}}

=== clipboard = a string ===

Stores `a string` of text in the system clipboard.

{{{
Shoes.app(:title => "Copy and Paste", :width => 450, :height => 250) do
   button "copy" do
      self.clipboard = "this is a Shoes string."
   end
   button "paste" do
      para clipboard()
   end
end
}}}

=== close() ===

Closes the app window.  If multiple windows are open and you want to close the
entire application, use the built-in method `exit`.

=== download(url: a string, styles) ===

Starts a download thread (much like XMLHttpRequest, if you're familiar with
JavaScript.)  This method returns immediately and runs the download in the
background.  Each download thread also fires `start`, `progress` and `finish`
events.  You can send the download to a file or just get back a string (in the
`finish` event.)

If you attach a block to a download, it'll get called as the `finish` event.

{{{
 #!ruby
 Shoes.app do
   stack do
     title "Searching Google", :size => 16
     @status = para "One moment..."

     # Search Google for 'shoes' and print the HTTP headers
     download "http://www.google.com/search?q=shoes" do |goog|
       @status.text = "Headers: " + goog.response.headers.inspect
     end
   end
 end
}}}

And, if we wanted to use the downloaded data, we'd get it using
`goog.response.body`.  This example is truly the simplest form of `download`:
pulling some web data down into memory and handling it once it's done.

Another simple use of `download` is to save some web data to a file, using the
`:save` style.

{{{
 #!ruby
 Shoes.app do
   stack do
     title "Downloading Google image", :size => 16
     @status = para "One moment..."

     download "http://www.google.com/logos/nasa50th.gif",
       :save => "nasa50th.gif" do
         @status.text = "Okay, is downloaded."
     end
   end
 end
}}}

In this case, you can still get the headers for the downloaded file, but
`response.body` will be `nil`, since the data wasn't saved to memory.  You will
need to open the file to get the downloaded goods.

If you need to send certain headers or actions to the web server, you can use
the `:method`, `:headers` and `:body` styles to customize the HTTP request.
(And, if you need to go beyond these, you can always break out Ruby's OpenURI
class.)

{{{
 #!ruby
 Shoes.app do
   stack do
     title "GET Google", :size => 16
     @status = para "One moment..."

     download "http://www.google.com/search?q=shoes", 
         :method => "GET" do |dump|
       @status.text = dump.response.body
     end
   end
 end
}}}

As you can see from the above example, Shoes makes use of the "GET" method to
query google's search engine.

=== location() » a string ===

Gets a string containing the URL of the current app.

=== mouse() » an array of numbers: button, left, top ===

Identifies the mouse cursor's location, along with which button is being
pressed.

{{{
 #!ruby
 Shoes.app do
   @p = para
   animate do
     button, left, top = self.mouse
     @p.replace "mouse: #{button}, #{left}, #{top}"
   end
 end
}}}

=== owner() » Shoes::App ===

Gets the app which launched this app.  In most cases, this will be `nil`.  But
if this app was launched using the [[Element.window]] method, the owner will be
the app which called `window`.

=== started?() » true or false ===

Has the window been fully constructed and displayed?  This is useful for
threaded code which may try to use the window before it is completely built.
(Also see the `start` event which fires once the window is open.)

=== visit(url: a string) ===

Changes the location, in order to view a different Shoes URL.

Absolute URLs (such as http://google.com) are okay, but Shoes will be expecting
a Shoes application to be at that address.  (So, google.com won't work, as it's
an HTML app.)

== The Styles Master List ==

You want to mess with the look of things?  Well, throughout Shoes, styles are
used to change the way elements appear.  In some cases, you can even style an
entire class of elements.  (Like giving all paragraphs a certain font.)

Styles are easy to spot.  They usually show up when the element is created.

{{{
 Shoes.app :title => "A Styling Sample" do
   para "Red with an underline", :stroke => red, :underline => "single"
 end
}}}

Here we've got a `:title` style on the app.  And on the paragraph inside the
app, a red `:stroke` style and an `:underline` style.

The style hash can also be changed by using the [[Common.style]] method,
available on every element and slot.

{{{
 Shoes.app :title => "A Styling Sample" do
   @text = para "Red with an underline"
   @text.style(:stroke => red, :underline => "single")
 end
}}}

Most styles can also be set by calling them as methods.  (I'd use the manual
search to find the method.)

{{{
 Shoes.app :title => "A Styling Sample" do
   @text = para "Red with an underline"
   @text.stroke = red
   @text.underline = "single"
 end
}}}

Rather than making you plow through the whole manual to figure out what styles
go where, this helpful page speeds through every style in Shoes and suggests
where that style is used.

=== :align » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''

The alignment of the text. It is either:

 * "left" - Align the text to the left.
 * "center" - Align the text in the center.
 * "right" - Align the text to the right.

=== :angle » a number ===

For: ''background, border, gradient''.

The angle at which to apply a gradient.  Normally, gradient colors range from
top to bottom.  If the `:angle` is set to 90, the gradient will rotate 90
degrees counter-clockwise and the gradient will go from left to right.

{{{
Shoes.app do
   fill gradient(red, green, angle: 35)
   oval 10, 10, 150
end
}}}

=== :attach » a slot or element ===

For: ''flow, stack''.

Pins a slot relative to another slot or element.  Also, one may write `:attach
=> Window` to position the slot at the window's top, left corner.  Taking this
a bit further, the style `:top => 10, :left => 10, :attach => Window` would
place the slot at (10, 10) in the window's coordinates.

If a slot is attached to an element that moves, the slot will move with it.  If
the attachment is reset to `nil`, the slot will flow in with the other objects
that surround, as normal.

=== :autoplay » true or false ===

For: ''video''.

Should this video begin playing after it appears?  If set to `true`, the video
will start without asking the user.

=== :bottom » a number ===

For: ''all slots and elements''.

Sets the pixel coordinate of an element's lower edge.  The edge is placed
relative to its container's lower edge.  So, `:bottom => 0` will align the
element so that its bottom edge and the bottom edge of its slot touch.

=== :cap » :curve or :rect or :project ===

For: ''arc, arrow, border, flow, image, mask, rect, star, shape, stack''.

Sets the shape of the line endpoint, whether curved or square.  See the
[[Art.cap]] method for more explanation.

=== :center » true or false ===

For: ''arc, image, oval, rect, shape''.

Indicates whether the `:top` and `:left` coordinates refer to the center of the
shape or not.  If set to `true`, this is similar to setting the
[[Art.transform]] method to `:center`.

=== :change » a proc ===

For: ''edit_box, edit_line, list_box''.

The `change` event handler is stored in this style.  See the [[EditBox.change]]
method for the edit_box, as an example.

=== :finish » a proc ===

For: ''edit_line''.

The `finish` handler is called (if set) when the user presses the Enter
or Return key in an edit_line.  See [[EditLine.finish]]

=== :checked » true or false ===

For: ''check, radio''.

Is this checkbox or radio button checked?  If set to `true`, the box is
checked.  Also see the [[Check.checked=]] method.

=== :choose » a string ===

For: ''list_box''.

Sets the currently chosen item in the list.  More information at
[[ListBox.choose]].

=== :click » a proc ===

For: ''arc, arrow, banner, button, caption, check, flow, image, inscription,
line, link, mask, oval, para, radio, rect, shape, stack, star, subtitle,
tagline, title''.

The `click` event handler is stored in this style.  See the [[Events.click]]
method for a description.

=== :curve » a number ===

For: ''background, border, rect''.

The radius of curved corners on each of these rectangular elements.  As an
example, if this is set to 6, the corners of the rectangle are given a curve
with a 6-pixel radius.

=== :dash » a string ===

For: ''arrow, border, line, oval, rect, shape''.

Defines the line style used to draw elements. It can be either:

 * :onedot - Creates dot-dash line.
 * :nodot - Creates solid line.

If dash style is undefined, ":nodot" is set as default.

{{{
Shoes.app width: 410, height: 60 do
   line 10,20,400,20, dash: :onedot, stroke: green, strokewidth: 3
   line 10,40,400,40, stroke: green, strokewidth: 3
end
}}}

=== :displace_left » a number ===

For: ''all slots and elements''.

Moves a shape, text block or any other kind of object to the left or right.  A
positive number displaces to the right by the given number of pixels; a
negative number displaces to the left.  Displacing an object doesn't effect the
actual layout of the page.  Before using this style, be sure to read the
[[Position.displace]] docs, since its behavior can be a bit surprising.

=== :displace_top » a number ===

For: ''all slots and elements''.

Moves a shape, text block or any other kind of object up or down.  A positive
number moves the object down by this number of pixels; a negative number moves
it up.  Displacing doesn't effect the actual layout of the page or the object's
true coordinates.  Read the [[Position.displace]] docs, since its behavior can
be a bit surprising.

=== :emphasis » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Styles the text with an emphasis (commonly italicized.)

This style recognizes three possible settings:

 * "normal" - the font is upright.
 * "oblique" - the font is slanted, but in a roman style.
 * "italic" - the font is slanted in an italic style. 

=== :family » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Styles the text with a given font family.  The string should contain the family
name or a comma-separated list of families.

=== :fill » a hex code, a Shoes::Color or a range of either ===

For: ''arc, arrow, background, banner, caption, code, del, em, flow, image,
ins, inscription, line, link, mask, oval, para, rect, shape, span, stack, star,
strong, sub, sup, subtitle, tagline, title''.

The color of the background pen.  For shapes, this is the fill color, the paint
inside the shape.  For text stuffs, this color is painted in the background (as
if marked with a highlighter pen.)

=== :font » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title, list_box''.

Styles the text with a font description.  The string is pretty flexible, but
can take the form "[FAMILY-LIST] [STYLE-OPTIONS] [SIZE]", where FAMILY-LIST is
a comma separated list of families optionally terminated by a comma,
STYLE_OPTIONS is a whitespace separated list of words where each WORD describes
one of style, variant, weight, stretch, or gravity, and SIZE is a decimal
number (size in points) or optionally followed by the unit modifier "px" for
absolute size. Any one of the options may be absent. If FAMILY-LIST is absent,
then the default font family (Arial) will be used.

Note: The list_box control will accept a font string when created but it is
not as flexible as textblock based font settings and there are no methods for
getting the current font or changing it after creation.

=== :group » a string ===

For: ''radio''.

Indicates what group a radio button belongs to.  Without this setting, radio
buttons are grouped together with other radio buttons in their immediate slot.
"Grouping" radio buttons doesn't mean they'll be grouped next to each other on
the screen.  It means that only one radio button from the group can be selected
at a time.

By giving this style a string, the radio button will be grouped with other
radio buttons that have the same group name.

=== :height » a number ===

For: ''all slots and elements''.

Sets the pixel height of this object.  If the number is a decimal number, the
height becomes a percentage of its parent's height (with 0.0 being 0% and 1.0
being 100%.)

=== :hidden » true or false ===

For: ''all slots and elements''.

Hides or shows this object.  Any object with `:hidden => true` are not
displayed on the screen.  Neither are its children.

=== :inner » a number ===

For: ''star''.

The size of the inner radius (in pixels.)  The inner radius describes the solid
circle within the star where the points begin to separate.

=== :items » an array ===

For: ''list_box''.

The list of selections in the list box.  See the [[Element.list_box]] method
for an example.

=== :justify » true or false ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''

Evenly spaces the text horizontally.

=== :kerning » a number ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Adds to the natural spacing between letters, in pixels.

=== :leading » a number ===

For: ''banner, caption, inscription, para, subtitle, tagline, title''.

Sets the spacing between lines in a text block.  Defaults to 4 pixels.

=== :left » a number ===

For: ''all slots and elements''.

Sets the left coordinate of this object to a specific pixel.  Setting `:left =>
10` places the object's left edge ten pixels away from the left edge of the
slot containing it.  If this style is left unset (or set to `nil`,) the object
will flow in with the other objects surrounding it.

You might also want to give it a :top, if it's acting a bit funny. Sometimes it needs both. :)

=== :margin » a number or an array of four numbers ===

For: ''all slots and elements''.

Margins space an element out from its surroundings.  Each element has a left,
top, right, and bottom margin.  If the `:margin` style is set to a single
number, the spacing around the element uniformly matches that number.  In other
words, if `:margin => 8` is set, all the margins around the element are set to
eight pixels in length.

This style can also be given an array of four numbers in the form `[left, top,
right, bottom]`.

=== :margin_bottom » a number ===

For: ''all slots and elements''.

Sets the bottom margin of the element to a specific pixel size.

=== :margin_left » a number ===

For: ''all slots and elements''.

Sets the left margin of the element to a specific pixel size.

=== :margin_right » a number ===

For: ''all slots and elements''.

Sets the right margin of the element to a specific pixel size.

=== :margin_top » a number ===

For: ''all slots and elements''.

Sets the top margin of the element to a specific pixel size.

=== :outer » a number ===

For: ''star''.

Sets the outer radius (half of the ''total'' width) of the star, in pixels.

=== :points » a number ===

For: ''star''.

How many points does this star have?  A style of `:points => 5` creates a
five-pointed star.

=== :radius » a number ===

For: ''arc, arrow, background, border, gradient, oval, rect, shape''.

Sets the radius (half of the diameter or total width) for each of these
elements.  Setting this is equivalent to setting both `:width` and `:height` to
double this number.

=== :right » a number ===

For: ''all slots and elements''.

Sets the pixel coordinate of an element's right edge.  The edge is placed
relative to its container's rightmost edge.  So, `:right => 0` will align the
element so that its own right edge and the right edge of its slot touch.
Whereas `:right => 20` will position the right edge of the element off to the
left of its slot's right edge by twenty pixels.

=== :rise » a number ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Lifts or plunges the font baseline for some text.  For example, a
[[Element.sup]] has a `:rise` of 10 pixels.  Conversely, the [[Element.sub]]
element has a `:rise` of -10 pixels.

=== :scroll » true or false ===

For: ''flow, stack, background''.

Establishes this slot as a scrolling slot.  If `:scroll => true` is set, the
slot will show a scrollbar if any of its contents go past its height.  The
scrollbar will appear and disappear as needed.  It will also appear inside the
width of the slot, meaning the slot's width will never change, regardless of
whether there is a scrollbar or not.

When used on a background instead of a flow or stack the background and set true
the background will always fill the slot when scrolled. See [[Element.background]].

=== :secret » true or false ===

For: ''ask, edit_line''.

Used for password fields, this setting keeps any characters typed in from
becoming visible on the screen.  Instead, a replacement character (such as an
asterisk) is show for each letter typed.

=== :size » a number ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Sets the pixel size for the font used inside this text block or text fragment.

Font size may also be augmented, through use of the following strings:

 * "xx-small" - 57% of present size.
 * "x-small" - 64% of present size.
 * "small" - 83% of present size.
 * "medium" - no change in size.
 * "large" - 120% of present size.
 * "x-large" - 143% of present size.
 * "xx-large" - 173% of present size.

=== :state » a string ===

For: ''button, check, edit_box, edit_line, list_box, radio, slider''.

The `:state` style is for disabling or locking certain controls, if you don't
want them to be edited.

Here are the possible style settings:

 * nil - the control is active and editable.
 * "readonly" - the control is active but cannot be edited.
 * "disabled" - the control is not active (grayed out) and cannot be edited.

=== :stretch » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Sets the font stretching used for a text object.

Possible settings are:

 * "condensed" - a smaller width of letters.
 * "normal" - the standard width of letters.
 * "expanded" - a larger width of letters.

=== :strikecolor » a Shoes::Color ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

The color used to paint any lines stricken through this text.

=== :strikethrough » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Is this text stricken through?  Two options here:

 * "none" - no strikethrough
 * "single" - a single-line strikethrough.

=== :stroke » a hex code, a Shoes::Color or a range of either ===

For: ''arc, arrow, banner, border, caption, code, del, em, flow, image, ins,
inscription, line, link, mask, oval, para, rect, shape, span, stack, star,
strong, sub, sup, subtitle, tagline, title''.

The color of the foreground pen.  In the case of shapes, this is the color the
lines are drawn with.  For paragraphs and other text, the letters are printed
in this color.

=== :strokewidth » a number ===

For: ''arc, arrow, border, flow, image, line, mask, oval, rect, shape, star, stack''.

The thickness of the stroke, in pixels, of the line defining each of these
shapes.  For example, the number two would set the strokewidth to 2 pixels.

=== :text » a string ===

For: ''button, edit_box, edit_line''.

Sets the message displayed on a button control, or the contents of an edit_box
or edit_line.

=== :top » a number ===

For: ''all slots and elements''.

Sets the top coordinate for an object, relative to its parent slot.  If an
object is set with `:top => 40`, this means the object's top edge will be
placed 40 pixels beneath the top edge of the slot that contains it.  If no
`:top` style is given, the object is automatically placed in the natural flow
of its slot.

You should probably give it a :left, too, if it's acting strange. It likes to have both. :)

=== :undercolor » a Shoes::Color ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

The color used to underline text.

=== :underline » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Dictates the style of underline used in the text.

The choices for this setting are:

 * "none" - no underline at all.
 * "single" - a continuous underline.
 * "double" - two continuous parallel underlines.
 * "low" - a lower underline, beneath the font baseline.  (This is generally recommended only for single characters, particularly when showing keyboard accelerators.)
 * "error" - a wavy underline, usually found indicating a misspelling.

=== :variant » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Vary the font for a group of text.  Two choices:

 * "normal" - standard font.
 * "smallcaps" - font with the lower case characters replaced by smaller variants of the capital characters. 

=== :weight » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title''.

Set the boldness of the text.  Commonly, this style is set to one of the
following strings:

 * "ultralight" - the ultralight weight (= 200)
 * "light" - the light weight (= 300)
 * "normal" - the default weight (= 400)
 * "semibold" - a weight intermediate between normal and bold (= 600)
 * "bold" - the bold weight (= 700)
 * "ultrabold" - the ultrabold weight (= 800)
 * "heavy" - the heavy weight (= 900)

However, you may also pass in the numerical weight directly.

=== :width » a number ===

For: ''all slots and elements''.

Sets the pixel width for the element.  If the number is a decimal, the width is
converted to a percentage (with 0.0 being 0% and 1.0 being 100%.)  A width of
100% means the object fills its parent slot.

=== :wrap » a string ===

For: ''banner, caption, code, del, em, ins, inscription, link, para, span,
strong, sub, sup, subtitle, tagline, title, list_box''

How should the text wrap when it fills its width? Possible options are:

 * "word" - Break lines at word breaks.
 * "char" - Break lines between characters, thus breaking some words.
 * "trim" - Cut the line off with an ellipsis if it goes too long.
 
 {{{
 Shoes.app do
   str = "Shoes is a tiny graphics toolkit. It's simple and straightforward. Shoes was born to be easy!"
   
   stack left: 100, width: 200 do
      para str, wrap: "word"
      para str, wrap: "char"
      para str, wrap: "trim"
   end
end
 }}}

== Classes List ==

Here is a complete list of all the classes introduced by Shoes.  This chart is
laid out according to how classes inherits from each other.  Subclasses are
indented one level to the right, beneath their parent class.

{INDEX}

== Colors List ==

The following list of colors can be used throughout Shoes.  As background
colors or border colors.  As stroke and fill colors.  Most of these colors come
from the X11 and HTML palettes.

All of these colors can be used by name.  (So calling the `tomato` method from
inside any slot will get you a nice reddish color.)  Below each color, also
find the exact numbers which can be used with the [[Built-in.rgb]] method.

{COLORS}

= Slots =

Slots are boxes used to lay out images, text and so on. The two most common
slots are `stacks` and `flows`. Slots can also be referred to as "boxes" or
"canvases" in Shoes terminology.

Since the mouse wheel and PageUp and PageDown are so pervasive on every
platform, vertical scrolling has really become the only overflow that matters.
So, in Shoes, just as on the web, width is generally fixed. While height goes
on and on.

Now, you can also just use specific widths and heights for everything, if you
want. That'll take some math, but everything could be perfect.

Generally, I'd suggest using stacks and flows. The idea here is that you want
to fill up a certain width with things, then advance down the page, filling up
further widths. You can think of these as being analogous to HTML's "block" and
"inline" styles.

==== Stacks ====

A stack is simply a vertical stack of elements. Each element in a stack is
placed directly under the element preceding it.

A stack is also shaped like a box. So if a stack is given a width of 250, that
stack is itself an element which is 250 pixels wide.

To create a new stack, use the [[Element.stack]] method, which is available
inside any slot.  So stacks can contain other stacks and flows.

==== Flows ====

A flow will pack elements in as tightly as it can. A width will be filled, then
will wrap beneath those elements. Text elements placed next to each other will
appear as a single paragraph. Images and widgets will run together as a series.

Like the stack, a flow is a box. So stacks and flows can safely be embedded
and, without respect to their contents, are identical. They just treat their
contents differently.

Making a flow means calling the [[Element.flow]] method.  Flows may contain
other flows and stacks.

Last thing: The Shoes window itself is a flow.

== Art for Slots ==

Each slot is like a canvas, a blank surface which can be covered with an
assortment of colored shapes or gradients.

Many common shapes can be drawn with methods like `oval` and `rect`.  You'll
need to set up the paintbrush colors first, though.

The `stroke` command sets the line color.  And the `fill` command sets the
color used to paint inside the lines.

{{{
 #!ruby
 Shoes.app do
   stroke red
   fill blue
   oval :top => 10, :left => 10,
     :radius => 100
 end
}}}

That code gives you a blue pie with a red line around it.  One-hundred pixels
wide, placed just a few pixels southeast of the window's upper left corner.

The `blue` and `red` methods above are Color objects.  See the section on
Colors for more on how to mix colors.

==== Inspiration from Processing and NodeBox ====

The artful methods generally come verbatim from NodeBox, a drawing kit for
Python.  In turn, NodeBox gets much of its ideas from Processing, a Java-like
language for graphics and animation.  I owe a great debt to the creators of
these wonderful programs!

Shoes does a few things differently from NodeBox and Processing.  For example,
Shoes has different color methods, including having its own Color objects,
though these are very similar to Processing's color methods.  And Shoes also
allows images and gradients to be used for drawing lines and filling in shapes.

Shoes also borrows some animation ideas from Processing and will continue to
closely consult Processing's methods as it expands.

=== arc(left, top, width, height, angle1, angle2) » Shoes::Shape ===

Draws an arc shape (a section of an oval) at coordinates (left, top).  This
method just give you a bit more control than [[Art.oval]], by offering the
`:angle1` and `:angle2` styles.  (In fact, you can mimick the `oval` method by
setting `:angle1` to 0 and `:angle2` to `Shoes::TWO_PI`.)

{{{
Shoes.app do
   fill red
   arc self.width / 2, self.height / 2, 150, 75, Shoes::PI, 0
   
   fill green
   arc self.width / 2, self.height / 2, 150, 75, 0, Shoes::PI
end
}}}

=== arrow(left, top, width) » Shoes::Shape ===

Draws an arrow at coordinates (left, top) with a pixel `width`.

{{{
 #!ruby
 Shoes.app do
   arrow 100, 100, 50
 end
}}}

=== cap(:curve or :rect or :project) » self ===

Sets the line cap, which is the shape at the end of every line you draw.  If
set to `:curve`, the end is rounded.  The default is `:rect`, a line which ends
abruptly flat.  The `:project` cap is also fat, but sticks out a bit longer.

{{{
Shoes.app do
   [:curve, :rect, :project].each_with_index do |n, m|
      cap n
      strokewidth 5
      stroke rgb(rand(255), rand(255), rand(255))
      line 50, 50 + (m * 25), self.width - 50, 50 + (m * 25)
   end
end
}}}

=== fill(pattern) » pattern ===

Sets the fill bucket to a specific color (or pattern.)  Patterns can be colors,
gradients or images.  So, once the fill bucket is set, you can draw shapes and
they will be colored in with the pattern you've chosen.

To draw a star with an image pattern:

{{{
 #!ruby
 Shoes.app do
   fill "#{DIR}/static/avatar.png"
   star 200, 200, 5
 end
}}}

To clear the fill bucket, use `nofill`.  And to set the line color (the border
of the star,) use the `stroke` method.

=== nofill() » self ===

Blanks the fill color, so that any shapes drawn will not be filled in.
Instead, shapes will have only a lining, leaving the middle transparent.

=== nostroke() » self ===

Empties the line color.  Shapes drawn will have no outer line.  If `nofill` is
also set, shapes drawn will not be visible.

=== line(left, top, x2, y2) » Shoes::Shape ===

Draws a line using the current line color (aka "stroke") starting at
coordinates (left, top) and ending at coordinates (x2, y2).

{{{
Shoes.app do
   100.times do |n|
      strokewidth rand(10)
      stroke rgb(rand(255), rand(255), rand(255))
      line rand(self.width), rand(self.height), rand(self.width), rand(self.height)
   end
end
}}}

=== Mask() » Shoes::Mask ===

Mask is a slot allowing to clip elements outside its own area. The size and frame of the area is defined by a number of Shoes elements - shapes, images and texts.

In the example below there are two same colour slots. The left slot is drawn with a green star 
while the right slot contains the green star used as a clipping mask. Notice how the colour of the star is not taken into account.

{{{
Shoes.app width: 300, height: 150 do
  flow width: 0.5, height: 1.0 do
    background orange
    star left: 75, top: 75, points: 6, outer: 40, inner: 9, fill: green
  end
	
  flow width: 0.5, height: 1.0 do
    background orange
    mask do
      star left: 75, top: 75, points: 6, outer: 40, inner: 9, fill: green
    end
  end
end
}}}

Next the same setup is used but this time an image is used for clipping. 

{{{
Shoes.app width: 300, height: 150 do
  flow width: 0.5, height: 1.0 do
    background orange
    image "#{DIR}/static/shoes-icon.png", left: 25, top: 25, width: 100
  end
	
  flow width: 0.5, height: 1.0 do
    background orange
    mask do
      image "#{DIR}/static/shoes-icon.png", left: 25, top: 25, width: 100
    end
  end
end
}}}

Texts can be used for their shape too.

{{{
Shoes.app width: 400, height: 100 do
  flow width: 0.5, height: 1.0 do
    background orange
    title "SHOES!", weight: "ultrabold", align: "center"
  end
	
  flow width: 0.5, height: 1.0 do
    background orange
    mask do
      title "SHOES!", weight: "ultrabold", align: "center"
    end
  end
end
}}}

Check the sample directory for more examples.

=== oval(left, top, radius) » Shoes::Shape ===

Draws a circular form at pixel coordinates (left, top) with a width and height
of `radius` pixels.  The line and fill colors are used to draw the shape.  By
default, the coordinates are for the oval's leftmost, top corner, but this can
be changed by calling the [[Art.transform]] method or by using the `:center`
style on the next method below.

{{{
 #!ruby
 Shoes.app do
   stroke blue
   strokewidth 4
   fill black
   oval 10, 10, 50
 end
}}}

To draw an oval of varied proportions, you may also use the syntax: `oval(left, top, width, height)`.

=== oval(styles) » Shoes::Shape ===

Draw circular form using a style hash.  The following styles are supported:

 * `top`: the y-coordinate for the oval pen.
 * `left`: the x-coordinate for the oval pen.
 * `radius`: the width and height of the circle.
 * `width`: a specific pixel width for the oval.
 * `height`: a specific pixel height for the oval.
 * `center`: do the coordinates specific the oval's center? (true or false)

These styles may also be altered using the `style` method on the Shape object.

=== rect(top, left, width, height, corners = 0) » Shoes::Shape ===

Draws a rectangle starting from coordinates (top, left) with dimensions of
width x height.  Optionally, you may give the rectangle rounded corners with a
fifth argument: the radius of the corners in pixels.

As with all other shapes, the rectangle is drawn using the stroke and fill colors.

{{{
 #!ruby
 Shoes.app do
   stroke rgb(0.5, 0.5, 0.7)
   fill rgb(1.0, 1.0, 0.9)
   rect 10, 10, self.width - 20, self.height - 20
 end
}}}

The above sample draws a rectangle which fills the area of its parent box,
leaving a margin of 10 pixels around the edge.  Also see the `background`
method for a rectangle which defaults to filling its parent box.

=== rect(styles) » Shoes::Shape ===

Draw a rectangle using a style hash.  The following styles are supported:

 * `top`: the y-coordinate for the rectangle.
 * `left`: the x-coordinate for the rectangle.
 * `curve`: the pixel radius of the rectangle's corners.
 * `width`: a specific pixel width for the rectangle.
 * `height`: a specific pixel height for the rectangle.
 * `center`: do the coordinates specific the rectangle's center? (true or false)

These styles may also be altered using the `style` method on the Shape object.

=== rotate(degrees: a number) » self ===

Rotates the pen used for drawing by a certain number of `degrees`, so that any
shapes will be drawn at that angle.

In this example below, the rectangle drawn at (30, 30) will be rotated 45 degrees.

{{{
 #!ruby
 Shoes.app do
   fill "#333"
   rotate 45
   rect 30, 30, 40, 40
 end
}}}

=== scale(sx: a float, sy: a float) » self ===

Scales the pen used for drawing by sx an sy in width and height respectively, so that any shapes will be drawn at that scale. 
Second argument is optional, in which case scaling will be the same in both direction.

0.5 means scaling to half the size, 2.0 doubles the size.

{{{
 #!ruby
 Shoes.app do
   nofill
   rect 30, 30, 100, 100, stroke: red
   fill "#333"
   scale 1.2, 0.8
   rect 30, 30, 100, 100
 end
}}}

=== skew(sx: a float, sy: a float) » self ===

Skews the pen used for drawing by sx an sy in width and height respectively, so that any shapes will be drawn skewed by those amounts. 
Second argument is optional, in which case skew happens only horizontally.

{{{
 #!ruby
 Shoes.app do
   fill "#333"
   skew 7.5, 9.5
   rect 30, 30, 100, 100
 end
}}}

=== shape(left, top) { ... } » Shoes::Shape ===

Describes an arbitrary shape to draw, beginning at coordinates (left, top) and
continued by calls to `line_to`, `move_to`, `curve_to` and `arc_to` inside the
block.  You can look at it as sketching a shape with a long line that curves
and arcs and bends.

{{{
 #!ruby
 Shoes.app do
   fill red(0.2)
   shape do
     move_to(90, 55)
     arc_to(50, 55, 50, 50, 0, Shoes::PI/2)
     arc_to(50, 55, 60, 60, Shoes::PI/2, Shoes::PI)
     arc_to(50, 55, 70, 70, Shoes::PI, Shoes::TWO_PI-Shoes::PI/2)
     arc_to(50, 55, 80, 80, Shoes::TWO_PI-Shoes::PI/2, Shoes::TWO_PI)
   end
 end
}}}

A shape can also contain other shapes.  So, you can place an [[Art.oval]], a
[[Art.rect]], a [[Art.line]], a [[Art.star]] or an [[Art.arrow]] (and all of
the other methods in this [[Art]] section) inside a shape, but they will not be
part of the line.  They will be more like a group of shapes are all drawn as
one.

=== shape(styles) { ... } » Shoes::Shape ===

Describes an arbitrary shape to draw, initialized using a style hash.  The following styles are relevant:

 * `top`: the y-coordinate for the shape.
 * `left`: the x-coordinate for the shape.
 * `center`: do the coordinates specifie the rectangle's center? (true or false).
 * `cap`: sets the line endpoints of the shape.
 * `stroke`: color of the outline of the shape.                  
 * `strokewidth`: size of the outline of the shape.
 * `fill`: color of the shape.

These styles may also be altered using the `style` method on the Shape object.

=== star(left, top, points = 10, outer = 100.0, inner = 50.0) » Shoes::Shape ===

Draws a star using the stroke and fill colors.  The star is positioned with its
center point at coordinates (left, top) with a certain number of `points`.  The
`outer` width defines the full radius of the star; the `inner` width specifies
the radius of the star's middle, where points stem from.

{{{
Shoes.app do
   10.times do |n|
      fill rgb(rand(255), rand(255), rand(255))
      star rand(self.width) + 50, rand(self.height) + 50, rand(10) + 5, rand(50) + 50, rand(50)
   end
end
}}}

=== stroke(pattern) » pattern ===

Set the active line color for this slot.  The `pattern` may be a color, a
gradient or an image, all of which are categorized as "patterns."  The line
color is then used to draw the borders of any subsequent shape.

So, to draw an arrow with a red line around it:

{{{
 #!ruby
 Shoes.app do
   stroke red
   arrow 100, 100, 50
 end
}}}

To clear the line color, use the `nostroke` method.

=== strokewidth(a number) » self ===

Sets the line size for all drawing within this slot.  Whereas the `stroke`
method alters the line color, the `strokewidth` method alters the line size in
pixels.  Calling `strokewidth(4)` will cause lines to be drawn 4 pixels wide.

=== transform(:center or :corner) » self ===

Should transformations (such as `skew` and `rotate`) be performed around the
center of the shape?  Or the corner of the shape?  Shoes defaults to `:corner`.

=== translate(left, top) » self ===

Moves the starting point of the drawing pen for this slot.  Normally, the pen
starts at (0, 0) in the top-left corner, so that all shapes are drawn from that
point.  With `translate`, if the starting point is moved to (10, 20) and a
shape is drawn at (50, 60), then the shape is actually drawn at (60, 80) on the
slot.

== Element Creation ==

Shoes has a wide variety of elements, many cherry-picked from HTML.  This page
describes how to create these elements in a slot.  See the Elements section of
the manual for more on how to modify and use these elements after they have
been placed.

=== animate(fps) { |frame| ... } » Shoes::Animation ===

Starts an animation timer, which runs parallel to the rest of the app.  The
`fps` is a number, the frames per seconds.  This number dictates how many times
per second the attached block will be called.

The block is given a `frame` number.  Starting with zero, the `frame` number
tells the block how many frames of the animation have been shown.

{{{
 #!ruby
 Shoes.app do
   @counter = para "STARTING"
   animate(24) do |frame|
     @counter.replace "FRAME #{frame}"
   end
 end
}}}

The above animation is shown 24 times per second.  If no number is given, the
`fps` defaults to 10.

=== background(pattern) » Shoes::Background ===

Draws a Background element with a specific color (or pattern.) Patterns can be
colors, gradients or images. Colors and images will tile across the
background.  Gradients stretch to fill the background.

{{{
 #!ruby
 Shoes.app do
   background black
   background white, :width => 50
 end
}}}

The above example paints two backgrounds.  First, a black background is painted
over the entire app's surface area.  Then a 50 pixel white stripe is painted
along the left side.

Background are reusable and can be copied because they inherit from Pattern.

{{{
Shoes.app do 
   stack(left: 0, top: 0, width: width / 4, height: height / 4) do
      @b = background "#{DIR}/static/stripe.png"
   end
   
   4.times do |n|
      stack(left: n * width / 4, top: n * height / 4, width: width / 4, height: height / 4) do
         background @b
      end
   end
end
}}}

Once a background is created it's size and location won't change unless the slot
is resized. If the slot has a scroll bar it may do what you think. Scroll thru
this example:

{{{
Shoes.app(title: "No Scroll", width: 300, height: 400, resizable: true ) do
    background green
    @main = stack left: 0.05, top: 0.15, width: 0.9, height: 0.8, scroll: true do
        background beige
        100.times do |i|
            para "#{i+1} times"
        end
    end
end
}}}

As of Shoes 3.3.3, You can ask Shoes to be more respectful of scrolling by setting scroll: true 
as this example does
{{{
Shoes.app(title: "Scroll", width: 300, height: 400, resizable: true ) do
    background green
    @main = stack left: 0.05, top: 0.15, width: 0.9, height: 0.8, scroll: true do
        background beige, scroll: true
        100.times do |i|
            para "#{i+1} times"
        end
    end
end
}}}

Be careful when using scroll: true. It may find a scrollbar you didn't want
to use and it's not Shoes 4 compatible. 

'''PLEASE NOTE:''' Backgrounds are actual elements, not styles.  HTML treats
backgrounds like styles.  Which means every box can only have one background.
Shoes layers background elements.

=== banner(text) » Shoes::Banner ===

Creates a Banner text block.  Shoes automatically styles this text to 48 pixels high.

=== border(text, :strokewidth => a number) » Shoes::Border ===

Draws a Border element using a specific color (or pattern). Patterns can be
colors, gradients or images. Colors and images will tile across the border.
Gradients stretch to fill the border.

=== border(pattern) » Shoes::Border ===

Draws a Border element with a specific pattern. Borders are reusable and can be copied 
because they inherit from Pattern.

{{{
Shoes.app do
   stack :width => 50, :height => 30 do
     @b = border red, :strokewidth => 5
     para "=^.^=", :stroke => green
   end

   12.times do |n|
      stack :left => n * 50, :top => height / 2, :width => 50 do
        border @b
        para "=^.^=", :stroke => green
      end
   end
end
}}}

'''PLEASE NOTE:''' Like Backgrounds, Borders are actual elements, not styles.
HTML treats backgrounds and borders like styles.  Which means every box can
only have one borders.  Shoes layers border and background elements, along with
text blocks, images, and everything else.

=== button(text) { ... } » Shoes::Button ===

Adds a push button with the message `text` written across its surface.  An
optional block can be attached, which is called if the button is pressed.

{{{
Shoes.app do
   button("push me") { alert "How dare ya!" }
end
}}}

=== caption(text) » Shoes::Caption ===

Creates a Caption text block.  Shoes styles this text to 14 pixels high.

=== check() » Shoes::Check ===

Adds a check box.

=== code(text) » Shoes::Code ===

Create a Code text fragment.  This text defaults to a monospaced font.

{{{
Shoes.app do
   para code %q[
      Shoes.app do
         para "Shoes version #{Shoes::VERSION_NUMBER}"
      end
   ]
end
}}}

=== del(text) » Shoes::Del ===

Creates a Del text fragment (short for "deleted") which defaults to text with a
single strikethrough in its middle.

=== dialog(styles) { ... } » Shoes::App ===

Opens a new app window (just like the [[Element.window]] method does,) but the
window is given a dialog box look.

=== edit_box(text) » Shoes::EditBox ===

Adds a large, multi-line textarea to this slot.  The `text` is optional and
should be a string that will start out the box.  An optional block can be
attached here which is called any type the user changes the text in the box.

{{{
 #!ruby
 Shoes.app do
   edit_box
   edit_box "HORRAY EDIT ME"
   edit_box "small one", :width => 100, :height => 160
 end
}}}

=== edit_line(text) » Shoes::EditLine ===

Adds a single-line text box to this slot.  The `text` is optional and should be
a string that will start out the box.  An optional block can be attached here
which is called any type the user changes the text in the box.

=== em(text) » Shoes::Em ===

Creates an Em text fragment (short for "emphasized") which, by default, is
styled with italics.

=== every(seconds) { |count| ... } » Shoes::Every ===

A timer similar to the `animation` method, but much slower.  This timer fires a
given number of seconds, running the block attached.  So, for example, if you
need to check a web site every five minutes, you'd call `every(300)` with a
block containing the code to actually ping the web site.

=== flow(styles) { ... } » Shoes::Flow ===

A flow is an invisible box (or "slot") in which you place Shoes elements.  Both
flows and stacks are explained in great detail on the main [[Slots]] page.

Flows organize elements horizontally.  Where one would use a [[Element.stack]]
to keep things stacked vertically, a flow places its contents end-to-end across
the page.  Once the end of the page is reached, the flow starts a new line of
elements.

=== image(path) » Shoes::Image ===

Creates an [[Image]] element for displaying a picture.  PNG, JPEG and GIF
formats are allowed.

The `path` can be a file path or a URL.  All images loaded are temporarily
cached in memory, but remote images are also cached locally in the user's
personal Shoes directory.  Remote images are loaded in the background; as with
browsers, the images will not appear right away, but will be shown when they
are loaded.

You can disable the remote image caching in several ways. For just this image,
append the hash arg 'cache: false` See [[AppMethods]] for the global way.

=== imagesize(path) » [width, height] ===

Quickly grab the width and height of an image.  The image won't be loaded into
the cache or displayed.

URGENT NOTE: This method cannot be used with remote images (loaded from HTTP,
rather than the hard drive.)

=== ins(text) » Shoes::Ins ===

Creates an Ins text fragment (short for "inserted") which Shoes styles with a
single underline.

=== inscription(text) » Shoes::Inscription ===

Creates an Inscription text block.  Shoes styles this text at 10 pixels high.

=== link(text, :click => proc or string) » Shoes::Link ===

Creates a Link text block, which Shoes styles with a single underline and
colors with a #06E (blue) colored stroke.

The default LinkHover style is also single-underlined with a #039 (dark blue) stroke.

{{{
Shoes.app do
   para link("click here\n", click: proc { |btn, left, top|
      alert "#{btn}, #{left}, #{top}\n"
   })
end
}}}

=== list_box(:items => [strings, ...]) » Shoes::ListBox ===

Adds a drop-down list box containing entries for everything in the `items`
array.  An optional block may be attached, which is called if anything in the
box becomes selected by the user.

{{{
 #!ruby
 Shoes.app do
   stack :margin => 10 do
     para "Pick a card:"
     list_box :items => ["Jack", "Ace", "Joker"]
   end
 end
}}}

Call `ListBox#text` to get the selected string.  See the `ListBox` section
under `Native` controls for more help.

=== progress() » Shoes::Progress ===

Adds a progress bar.

=== para(text) » Shoes::Para ===

Create a Para text block (short for "paragraph") which Shoes styles at 12
pixels high.

=== radio(group name: a string or symbol) » Shoes::Radio ===

Adds a radio button.  If a `group name` is given, the radio button is
considered part of a group.  Among radio buttons in the same group, only one
may be checked.  (If no group name is given, one is created that only
contains this radio button. 

=== span(text) » Shoes::Span ===

Creates a Span text fragment, unstyled by default.

=== stack(styles) { ... } » Shoes::Stack ===

Creates a new stack.  A stack is a type of slot.  (See the main [[Slots]] page
for a full explanation of both stacks and flows.)

In short, stacks are an invisible box (a "slot") for placing stuff.  As you add
things to the stack, such as buttons or images, those things pile up
vertically.  Yes, they stack up!

=== strong(text) » Shoes::Strong ===

Creates a Strong text fragment, styled in bold by default.

=== sub(text) » Shoes::Sub ===

Creates a Sub text fragment (short for "subscript") which defaults to lowering
the text by 10 pixels and styling it in an x-small font.

=== subtitle(text) » Shoes::Subtitle ===

Creates a Subtitle text block.  Shoes styles this text to 26 pixels high.

=== sup(text) » Shoes::Sup ===

Creates a Sup text fragment (short for "superscript") which defaults to raising
the text by 10 pixels and styling it in an x-small font.

=== tagline(text) » Shoes::Tagline ===

Creates a Tagline text block.  Shoes styles this text to 18 pixels high.

=== timer(seconds) { ... } » Shoes::Timer ===

A one-shot timer.  If you want to schedule to run some code in a few seconds
(or minutes, hours) you can attach the code as a block here.

To display an alert box five seconds from now:


{{{
 #!ruby
 Shoes.app do
   timer(5) do
     alert("Your five seconds are up.")
   end
 end
}}}

You can can create timers for fractions of a second: timer(0.1) is something
you might see if you poke around inside Shoes 

=== title(text) » Shoes::Title ===

Creates a Title text block.  Shoes styles these elements to 34 pixels high.

=== video(path or url) » Shoes::Video ===

Embeds a movie in this slot.

=== window(styles) { ... } » Shoes::App ===

Opens a new app window.  This method is almost identical to the
[[App.Shoes.app]] method used to start an app in the first place.  The
difference is that the `window` method sets the new window's [[App.owner]]
property.  (A normal Shoes.app has its `owner` set to `nil`.)

So, the new window's `owner` will be set to the Shoes::App which launched the
window.  This way the child window can call the parent.

{{{
 #!ruby
 Shoes.app :title => "The Owner" do
   button "Pop up?" do
     window do
       para "Okay, popped up from #{owner}"
     end
   end
 end
}}}

== Events ==

Wondering how to catch stray mouse clicks or keyboard typing?  Events are sent
to a slot whenever a mouse moves inside the slot.  Or whenever a key is
pressed.  Even when the slot is created or destroyed.  You can attach a block
to each of these events.

Mouse events include `motion`, `click`, `wheel`, `hover` and `leave`.  Keyboard typing
is represented by the `keypress` event.  And the `start` and `finish` events
indicate when a canvas comes into play or is discarded.

So, let's say you want to change the background of a slot whenever the mouse
floats over it.  We can use the `hover` event to change the background when the
mouse comes inside the slot.  And `leave` to change back when the mouse floats
away.

The mouse related events also provide a mods value that reports whether the
control, shift or both keys were held down during the event. The mods will be empty (nil),
or a string of 'control', 'shift' or 'control_shift'. This was introduced in
Shoes 3.3.5. Older scripts still work.


{{{
 #!ruby
 Shoes.app do
   s = stack :width => 200, :height => 200 do
     background red
     hover do
       s.clear { background blue }
     end
     leave do
       s.clear { background red }
     end
   end
 end
}}}

=== click { |button, left, top, mods| ... } » self ===

The click block is called when a mouse button is clicked.  The `button` is the
number of the mouse button which has been pressed.  The `left` and `top` are
the mouse coordinates at which the click happened.

To catch the moment when the mouse is unclicked, see the [[Events.release]] event.

NOTE: only button numbers of 1,2,3 (left, wheel-press, right) are available
for all platforms and mice. If you have an exotic mouse you can get higher
button numbers but you should not expect other users have such a device.

{{{
Shoes.app do
   click do |btn, left, top|
      para "#{btn}, #{left}, #{top}, \n"
   end
end
}}}

=== wheel { |dir, left, top, mods| ...} » self ===

The wheel block is called when the mouse wheel is scrolled up or down. dir
is 0 or 1. Beware! No one knows if 1 is up or down since it can be changed
by the users operating system.  Like click, wheel is attatched to a slot so
you can have many of them.

{{{
Shoes.app do
  stack height: 200 do
    click do |b,l,t|
     @p.replace "Stack clicked"
    end
    @p = para "None"
    flow width: 200 do 
      para "Flow 1"
      wheel do |d,l,t| 
       @p.replace  "Flow 1 wheel #{d}"
      end
    end
    flow width: 200 do
      para "Flow 2"
      click do |b,l,t|
       @p.replace "Flow 2 clicked"
      end
    end
  end
  wheel {|d,l,t,mods| @p.replace "default slot wheel #{d} #{mods}"}
end
}}}

Notice that the `mods` is only supplied in the outer most `wheel`. Its ignored
if you don't ask for mods.

=== finish { |self| ... } » self ===

When a slot is removed, it's finish event occurs.  The finish block is
immediately handed `self`, the slot object which has been removed.

=== hover { |self| ... } » self ===

The hover event happens when the mouse enters the slot.  The block gets `self`,
meaning the object which was hovered over.

To catch the mouse exiting the slot, check out the [[Events.leave]] event.

=== keydown { |key| ... } » self ===

Triggered whenever a single key is pressed, the block gets called. The block is sent a key which is a string representing the character (such as the letter or number) on the key.  For special keys (not modifiers keys), a Ruby symbol is sent, rather than a string, see [[Events.keypress]] for a list of special keys.

{{{
 #!ruby
 Shoes.app {
   @info = para "Press a key."
   keydown do |k|
      @info.replace "#{k} was PRESSED."
   end
}
}}}

=== keyup { |key| ... } » self ===

Triggered whenever a single key is released, the block gets called. The block is sent a key which is a string representing the character (such as the letter or number) on the key.  For special keys (not modifiers keys), a Ruby symbol is sent, rather than a string, see [[Events.keypress]] for a list of special keys.

{{{
 #!ruby
 Shoes.app {
   @info = para "Press a key and release it."
   keyup do |k|
      @info.replace "#{k} was RELEASED."
   end
}
}}}

=== keypress { |key| ... } » self ===

Whenever a key (or combination of keys) is pressed, the block gets called, and will be repeatedly called as long as it is pressed.  The
block is sent a `key` which is a string representing the character (such as the
letter or number) on the key.  For special keys and key combos, a Ruby symbol
is sent, rather than a string.

So, for example, if `Shift-a` is pressed, the block will get the string `"A"`.

However, if the F1 key is pressed, the `:f1` symbol is received.  For
`Shift-F1`, the symbol would be `:shift_f1`.

The modifier keys are `control`, `shift` and `alt`.  They appear in that order.
If `Shift-Control-Alt-PgUp` is pressed, the symbol will be
`:control_shift_alt_page_up`.

One thing about the shift key.  You won't see the shift key on most keys.  On
US keyboards, `Shift-7` is an ampersand.  So you'll get the string `"&"` rather
than `:shift_5`.  And, if you press `Shift-Alt-7` on such a keyboard, you'll
get the symbol: `:alt_&`.  You'll only see the shift modifier on the special
keys listed a few paragraphs down.

{{{
 #!ruby
 Shoes.app do
   @info = para "NO KEY is PRESSED."
   keypress do |k|
     @info.replace "#{k.inspect} was PRESSED."
   end
 end
}}}

Keep in mind that Shoes itself uses a few hotkeys.  Alt-Period (`:alt_.`),
Alt-Question (`:alt_?`) and Alt-Slash (`:alt_/`) are reserved for Shoes.

The list of special keys is as follows: `:escape`, `:delete`, `:backspace`,
`:tab`, `:page_up`, `:page_down`, `:home`, `:end`, `:left`, `:up`, `:right`,
`:down`, `:f1`, `:f2`, `:f3`, `:f4`, `:f5`, `:f6`, `:f7`, `:f8`, `:f9`, `:f10`,
`:f11` and `:f12`.

One caveat to all of those rules: normally the Return key gives you a string
`"\n"`.  When pressed with modifier keys, however, you end up with
`:control_enter`, `:control_alt_enter`, `:shift_alt_enter` and the like.

=== leave { |self| ... } » self ===

The leave event takes place when the mouse cursor exits a slot.  The moment it
no longer is inside the slot's edges.  When that takes place, the block is
called with `self`, the slot object which is being left.

Also see [[Events.hover]] if you'd like to detect the mouse entering a slot.

=== motion { |left, top, mods| ... } » self ===

The motion block gets called every time the mouse moves around inside the slot.
The block is handed the cursor's `left` and `top` coordinates and the optional mods.

{{{
 #!ruby
 Shoes.app :width => 200, :height => 200 do
   background black
   fill white
   @circ = oval 0, 0, 100, 100

   motion do |left, top|
     @circ.move left - 50, top - 50
   end
 end
}}}

=== release { |button, left, top| ... } » self ===

The release block runs whenever the mouse is unclicked (on mouse up).  When the
finger is lifted.  The `button` is the number of the button that was depressed.
The `left` and `top` are the coordinates of the mouse at the time the button
was released.

To catch the actual mouse click, use the [[Events.click]] event.

=== start { |self| ... } » self ===

The first time the slot is drawn, the start event fires.  The block is handed
`self`, the slot object which has just been drawn.

== Manipulation Blocks ==

The manipulation methods below make quick work of shifting around slots and
inserting new elements.

=== append() { ... } » self ===

Adds elements to the end of a slot.

{{{
 #!ruby
 Shoes.app do
   @slot = stack { para 'Good Morning' }
   timer 3 do
     @slot.append do
       title "Breaking News"
       tagline "Astronauts arrested for space shuttle DUI."
     end
   end
 end
}}}

The `title` and `tagline` elements will be added to the end of the `@slot`.

=== after(element) { ... } » self ===

Adds elements to a specific place in a slot, just after the `element` which is
a child of the slot.

The command should be executed for the slot (slot.after) where the entry will be added.
The element should be a full path (slot.element) after which the new entry will be pushed.

{{{
 #!ruby
Shoes.app do
	@my_stack = stack do
		background yellow
		para 'number 1'
		para 'number 2'
		para 'number 3'
		para 'number 4'
	end
       @my_stack.after(@my_stack.contents[1] ) do
		para 'number 1.5'
	end
end
}}}

=== before(element) { ... } » self ===

Adds elements to a specific place in a slot, just before the `element` which is
a child of the slot.

The command should be executed for the slot (slot.before) where the entry will be added.
The element should be a full path (slot.element) before which the new entry will be pushed.

{{{
 #!ruby
Shoes.app do
	@my_stack = stack do
		background yellow
		para 'number 1'
		para 'number 2'
		para 'number 3'
		para 'number 4'
	end
       @my_stack.before(@my_stack.contents[2] ) do
		para 'number 1.5'
	end
end
}}}

=== clear() » self ===

Empties the slot of any elements, timers and nested slots.  This is effectively
identical to looping through the contents of the slot and calling each
element's `remove` method.

=== clear() { ... } » self ===

The clear method also takes an optional block.  The block will be used to
replace the contents of the slot.

{{{
 #!ruby
 Shoes.app do
   @slot = stack { para "Old text" }
   timer 3 do
     @slot.clear { para "Brand new text" }
   end
 end
}}}

In this example, the "Old text" paragraph will be cleared out, replaced by the
"Brand new text" paragraph.

=== prepend() { ... } » self ===

Adds elements to the beginning of a slot.

{{{
 #!ruby
 Shoes.app do
   @slot = stack { para 'Good Morning' }
   timer 3 do
     @slot.prepend { para "Your car is ready." }
   end
 end
}}}

The `para` element is added to the beginning of the `@slot`.

=== refresh() ===

Sometimes you want the slot to be drawn as soon as possible, to update an inside background color for example. That methods urges Shoes to do so.

== Position of a Slot ==

Like any other element, slots can be styled and customized when they are created.

To set the width of a stack to 150 pixels:

{{{
 #!ruby
 Shoes.app do
   stack(:width => 150) { para "Now that's precision." }
 end
}}}

Each style setting also has a method, which can be used to grab that particular
setting.  (So, like, the `width` method returns the width of the slot in
pixels.)

=== displace(left: a number, top: a number) » self ===

A shortcut method for setting the :displace_left and :displace_top styles.
Displacing is a handy way of moving a slot without altering the layout.  In
fact, the `top` and `left` methods will not report displacement at all.  So,
generally, displacement is only for temporary animations.  For example,
jiggling a button in place.

The `left` and `top` numbers sent to `displace` are added to the slot's own
top-left coordinates.  To subtract from the top-left coordinate, use negative
numbers.

=== gutter() » a number ===

The size of the scrollbar area.  When Shoes needs to show a scrollbar, the
scrollbar may end up covering up some elements that touch the edge of the
window.  The `gutter` tells you how many pixels to expect the scrollbar to
cover.

This is commonly used to pad elements on the right, like so:

{{{
 #!ruby
 Shoes.app do
   stack :margin_right => 20 + gutter do
     para "Insert fat and ratified declaration of independence here..."
   end
 end
}}}

=== height() » a number ===

The vertical size of the viewable slot in pixels.  So, if this is a scrolling
slot, you'll need to use `scroll_height()` to get the full size of the slot.

=== hide() » self ===

Hides the slot, so that it can't be seen.  See also [[Position.show]] and [[Position.toggle]].

=== left() » a number ===

The left pixel location of the slot.  Also known as the x-axis coordinate.

=== move(left, top) » self ===

Moves the slot to specific coordinates, the (left, top) being the upper left
hand corner of the slot.

=== remove() » self ===

Removes the slot. It will no longer be displayed and will not be listed in its
parent's contents. It's gone.

=== scroll() » true or false ===

Is this slot allowed to show a scrollbar? True or false. The scrollbar will
only appear if the height of the slot is also fixed.

=== scroll = true or false ===

Establishes this slot as a scrolling slot.  If `scroll = true` is set, the
slot will show a scrollbar if any of its contents go past its height.  The
scrollbar will appear and disappear as needed.
See also the [[Styles.scroll]] style.

=== scroll_height() » a number ===

The vertical size of the full slot, including any of it which is hidden by scrolling.

=== scroll_max() » a number ===

The top coordinate which this slot can be scrolled down to.  The top coordinate
of a scroll bar is always zero.  The bottom coordinate is the full height of
the slot minus one page of scrolling.  This bottom coordinate is what
`scroll_max` returns.

This is basically a shortcut for writing `slot.scroll_height - slot.height`.

To scroll to the bottom of a slot, use `slot.scroll_top = slot.scroll_max`.

=== scroll_top() » a number ===

The top coordinate which this slot is scrolled down to.  So, if the slot is
scrolled down twenty pixels, this method will return `20`.

=== scroll_top = a number ===

Scrolls the slot to a certain coordinate.  This must be between zero and
`scroll_max`.

=== show() » self ===

Reveals the slot, if it is hidden.  See also [[Position.hide]] and
[[Position.toggle]].

=== style() » styles ===

Calling the `style` method with no arguments returns a hash of the styles
presently applied to this slot.

While methods such as `height` and `width` return the true pixel dimensions of
the slot, you can use `style[:height]` or `style[:width]` to get the dimensions
originally requested.

{{{
 #!ruby
 Shoes.app do
   @s = stack :width => "100%"
   para @s.style[:width]
 end
}}}

In this example, the paragraph under the stack will display the string "100%".

=== style(styles) » styles ===

Alter the slot using a hash of style settings.  Any of the methods on this page
(aside from this method, of course) can be used as a style setting.  So, for
example, there is a `width` method, thus there is also a `width` style.

{{{
 #!ruby
 Shoes.app do
   @s = stack { background green }
   @s.style(:width => 400, :height => 200)
 end
}}}

=== toggle() » self ===

Hides the slot, if it is shown.  Or shows the slot, if it is hidden.

=== top() » a number ===

The top pixel location of the slot.  Also known as the y-axis coordinate.

=== width() » a number ===

The horizontal size of the slot in pixels.

== Traversing the Page ==

You may find yourself needing to loop through the elements inside a slot. Or
maybe you need to climb the page, looking for a stack that is the parent of an
element.

On any element, you may call the `parent` method to get the slot directly above
it. And on slots, you can call the `contents` method to get all of the
children. (Some elements, such as text blocks, also have a `contents` method
for getting their children.)

=== contents() » an array of elements ===

Lists all elements in a slot.

=== parent() » a Shoes::Stack or Shoes::Flow ===

Gets the object for this element's container.

= Elements =

Ah, here's the stuff of Shoes. An element can be as simple as an oval shape. Or
as complex as a video stream. You've encountered all of these elements before
in the Slots section of the manual.

Shoes has seven native controls: the Button, the EditLine, the EditBox, the
ListBox, the Progress meter, the Check box and the Radio.  By "native"
controls, we mean that each of these seven elements is drawn by the operating
system.  So, a Progress bar will look one way on Windows and another way on OS
X.

Shoes also has seven basic other types of elements: Background, Border, Image,
Shape, TextBlock, Timer and Video.  These all should look and act the same on
every operating system.

Once an element is created, you will often still want to change it. To move it
or hide it or get rid of it. You'll use the commands in this section to do that
sort of stuff. (Especially check out the [[Common Common Methods]] section for
commands you can use on any element.)

So, for example, use the `image` method of a Slot to place a PNG on the screen.
The `image` method gives you back an Image object. Use the methods of the Image
object to change things up.

== Common Methods ==

A few methods are shared by every little element in Shoes.  Moving, showing,
hiding.  Removing an element.  Basic and very general things.  This list
encompasses those common commands.

One of the most general methods of all is the `style` method (which is also
covered as the [[Position.style]] method for slots.)

{{{
 #!ruby
 Shoes.app do
   stack do
     # Background, text and a button: both are elements!
     @back  = background green
     @text  = banner "A Message for You, Rudy"
     @press = button "Stop your messin about!"

     # And so, both can be styled.
     @text.style :size => 12, :stroke => red, :margin => 10
     @press.style :width => 400
     @back.style :height => 10
   end
 end
}}}

For specific commands, see the other links to the left in the Elements section.
Like if you want to pause or play a video file, check the [[Video]] section,
since pausing and playing is peculiar to videos.  No sense pausing a button.

=== displace(left: a number, top: a number) » self ===

Displacing an element moves it.  But without changing the layout around it.
This is great for subtle animations, especially if you want to reserve a place
for an element while it is still animating.  Like maybe a quick button shake or
a slot sliding into view.

When you displace an element, it moves relative to the upper-left corner where
it was placed.  So, if an element is at the coordinates (20, 40) and you
displace it 2 pixels left and 6 pixels on top, you end up with the coordinates
(22, 46).

{{{
 #!ruby
 Shoes.app do
   flow :margin => 12 do
     # Set up three buttons
     button "One"
     @two = button "Two"
     button "Three"

     # Bounce the second button
     animate do |i|
       @two.displace(0, (Math.sin(i) * 6).to_i)
     end
   end
 end
}}}

Notice that while the second button bounces, the other two buttons stay put.
If we used a normal `move` in this situation, the second button would be moved
out of the layout and the buttons would act as if the second button wasn't
there at all.  (See the [[Common.move]] example.)

'''Of particular note:''' if you use the `left` and `top` methods to get the
coordinates of a displaced element, you'll just get back the normal
coordinates.  As if there was no displacement.  Displacing is just intended for
quick animations!

=== height() » a number ===

The vertical screen size of the element in pixels. In the case of images, this
is not the full size of the image. This is the height of the element as it is
shown right now.

If you have a 150x150 pixel image and you set the width to 50 pixels, this
method will return 50.

Also see the [[Common.width]] method for an example and some other comments.

=== hide() » self ===

Hides the element, so that it can't be seen.  See also [[Common.show]] and
[[Common.toggle]].

=== left() » a number ===

Gets you the pixel position of the left edge of the element.

=== move(left: a number, top: a number) » self  ===

Moves the element to a specific pixel position within its slot.  The element is
still inside the slot.  But it will no longer be stacked or flowed in with the
other stuff in the slot.  The element will float freely, now absolutely
positioned instead.

{{{
 #!ruby
 Shoes.app do
   flow :margin => 12 do
     # Set up three buttons
     button "One"
     @two = button "Two"
     button "Three"

     # Bounce the second button
     animate do |i|
       @two.move(40, 40 + (Math.sin(i) * 6).to_i)
     end
   end
 end
}}}

The second button is moved to a specific place, allowing the third button to
slide over into its place.  If you want to move an element without shifting
other pieces, see the [[Common.displace]] method.

=== parent() » a Shoes::Stack or Shoes::Flow ===

Gets the object for this element's container.  Also see the slot's
[[Traversing.contents]] to do the opposite: get a container's elements.

=== remove() » self ===

Removes the element from its slot.  (In other words: throws it in the garbage.)
The element will no longer be displayed.

=== show() » self ===

Reveals the element, if it is hidden.  See also [[Common.hide]] and
[[Common.toggle]].

=== style() » styles ===

Gives you the full set of styles applied to this element, in the form of a
Hash.  While methods like `width` and `height` and `top` give you back specific
pixel dimensions, using `style[:width]` or `style[:top]`, you can get the
original setting (things like "100%" for width or "10px" for top.)

{{{
 #!ruby
 Shoes.app do
   # A button which take up the whole page
   @b = button "All of it", :width => 1.0, :height => 1.0

   # When clicked, show the styles
   @b.click { alert(@b.style.inspect) }
 end
}}}

=== style(styles) » styles ===

Changes the style of an element.  This could include the `:width` and `:height`
of an element, the font `:size` of some text, the `:stroke` and `:fill` of a
shape.  Or any other number of style settings.

=== toggle() » self ===

Hides an element if it is shown.  Or shows the element, if it is hidden.

=== tooltip() » a string ===

Returns a string containing the tooltip text from an element. 

{{{
#!ruby
Shoes.app do
   button "push me!", tooltip: "push me at your own risk..." do
      alert("...seriously?")
   end
end
}}}

=== tooltip = a string ===

Set the tooltip text from an element with the given string.

{{{
Shoes.app do
   @e = edit_line
   @b = button "set tooltip" do
      @e.tooltip = @e.text
      @b.tooltip = @e.text
      @b2.tooltip = @e.text
   end
   @b2 = button "get tooltip" do
      @p.text = @b.tooltip
   end
   @p = para
end
}}}

=== top() » a number ===

Gets the pixel position of the top edge of the element.

=== width() » a number ===

Gets the pixel width for the full size of the element.  This method always
returns an exact pixel size.  In the case of images, this is not the full width
of the image, just the size it is shown at.  See the [[Common.height]] method
for more.

Also, if you create an element with a width of 100% and that element is inside
a stack which is 120 pixels wide, you'll get back `120`.  However, if you call
`style[:width]`, you'll get `"100%"`.

{{{
 #!ruby
 Shoes.app do
   stack :width => 120 do
     @b = button "Click me", :width => "100%" do
       alert "button.width = #{@b.width}\n" +
         "button.style[:width] = #{@b.style[:width]}"
     end
   end
 end
}}}

In order to set the width, you'll have to go through the [[Common.style]]
method again.  So, to set the button to 150 pixels wide: `@b.style(:width =>
150)`.

To let Shoes pick the element's width, go with `@b.style(:width => nil)` to
empty out the setting.

== Background ==

A background is a color, a gradient or an image that is painted across an
entire slot.  Both backgrounds and borders are a type of Shoes::Pattern.
!{:margin_left => 100}man-ele-background.png!

Even though it's called a ''background'', you may still place this element in
front of other elements.  If a background comes after something else painted on
the slot (like a `rect` or an `oval`,) the background will be painted over that
element.

The simplest background is just a plain color background, created with the
[[Element.background]] method, such as this black background:

{{{
 #!ruby
 Shoes.app do
   background black
 end
}}}

A simple background like that paints the entire slot that contains it.  (In
this case, the whole window is painted black.)

You can use styles to cut down the size or move around the background to your liking.

To paint a black background across the top fifty pixels of the window:

{{{
 #!ruby
 Shoes.app do
   background black, :height => 50
 end
}}}

Or, to paint a fifty pixel column on the right-side of the window:

{{{
 #!ruby
 Shoes.app do
   background black, :width => 50, :right => 50
 end
}}}

Since Backgrounds are normal elements as well, see also the start of the
[[Elements]] section for all of its other methods.

== Border ==

A border is a color, gradient or image painted in a line around the edge of any
slot.  Like the Background element in the last section, a Border is a kind of
Shoes::Pattern. !{:margin_left => 100}man-ele-border.png!

The first, crucial thing to know about border is that all borders paint a line
around the '''inside''' of a slot, not the outside.  So, if you have a slot
which is fifty pixels wide and you paint a five pixel border on it, that means
there is a fourty pixel wide area inside the slot which is surrounded by the
border.

This also means that if you paint a Border on top of a [[Background]], the
edges of the background will be painted over by the border.

Here is just such a slot:

{{{
 #!ruby
 Shoes.app do
   stack :width => 50 do
     border black, :strokewidth => 5
     para "=^.^=", :stroke => green
   end
 end
}}}

If you want to paint a border around the outside of a slot, you'll need to wrap
that slot in another slot.  Then, place the border in the outside slot.

{{{
 #!ruby
 Shoes.app do
   stack :width => 60 do
     border black, :strokewidth => 5
     stack :width => 50 do
       para "=^.^=", :stroke => green
     end
   end
 end
}}}

In HTML and many other languages, the border is painted on the outside of the
box, thus increasing the overall width of the box.  Shoes was designed with
consistency in mind, so that if you say that a box is fifty pixels wide, it
stays fifty pixels wide regardless of its borders or margins or anything else.

Please also check out the [[Elements]] section for other methods used on borders.

== Button ==

Buttons are, you know, push buttons.  You click them and they do something.
Buttons are known to say "OK" or "Are you sure?"  And, then, if you're sure,
you click the button. !{:margin_left => 100}man-ele-button.png!

{{{
 #!ruby
 Shoes.app do
   button "OK!"
   button "Are you sure?"
 end
}}}

The buttons in the example above don't do anything when you click them. In
order to get them to work, you've got to hook up a block to each button.

{{{
 #!ruby
 Shoes.app do
   button "OK!" do
     append { para "Well okay then." }
   end
   button "Are you sure?" do
     append { para "Your confidence is inspiring." }
   end
 end
}}}

So now we've got blocks for the buttons. Each block appends a new paragraph to
the page. The more you click, the more paragraphs get added.

It doesn't go much deeper than that. A button is just a clickable phrase.

Just to be pedantic, though, here's another way to write that last example.

{{{
 #!ruby
 Shoes.app do
   @b1 = button "OK!"
   @b1.click { para "Well okay then." }
   @b2 = button "Are you sure?"
   @b2.click { para "Your confidence is inspiring." }
 end
}}}

This looks dramatically different, but it does the same thing.  The first
difference: rather than attaching the block directly to the button, the block
is attached later, through the `click` method.

The second change isn't related to buttons at all.  The `append` block was
dropped since Shoes allows you to add new elements directly to the slot.  So we
can just call `para` directly.  (This isn't the case with the `prepend`,
`before` or `after` methods.)

Beside the methods below, buttons also inherit all of the methods that are
[[Common]] but not all of them work. See styles below.

=== click() { |self| ... } » self ===

When a button is clicked, its `click` block is called.  The block is handed
`self`.  Meaning: the button which was clicked.

=== focus() » self ===

Moves focus to the button.  The button will be highlighted and, if the user
hits Enter, the button will be clicked.

=== button styles ===

Shoes 3.3.6 added support for changing the font, font stroke color, tiny icons

{{{
 #!ruby
 Shoes.app do
   flow do
     button "Button", font: "Menlo Bold 14",width: 200, stroke: red,
          tooltip: "Menlo Bold 14" do
     end
     button "icon", width: 80, height: 30, icon: "#{DIR}/static/icon-info.png",
          tooltip: "default right", stroke: blue do
     end
   end
 end
}}}

`Do not` set height: - It will not work and it won't look right on OSX and arguably does't
look right when it does work for you. Note that the tiny icon is in `addition` to the string. It
is not a button made from an image - that you do for your self with Image and a click {}. 

The icon should fit inside the button - it `will not` be downsized to fit.
You have a few options for placing the itty bitty icon releative to the title string,
left, right. If no title is provided and no position is given, then the icon in centered.

{{{
 #!ruby
 Shoes.app do
   flow do
      button "left", width: 80, icon: "#{DIR}/static/icon-info.png",
          icon_pos: "left", tooltip: "title left" do
      end
      button  width: 80, icon: "#{DIR}/static/icon-info.png",
          tooltip: "just icon" do
      end
      button "right", width: 80, icon: "#{DIR}/static/icon-info.png",
          icon_pos: "right", tooltip: "title right" do
      end
    end
  end
}}}

Warning! If you speculate that there is a top and a bottom icon_pos you are also
speculating that you can change the height of the button and I've told before that
OSX won't do that so you shouldn't either.  Unsupported to the max. 

== Check ==

Check boxes are clickable square boxes than can be either checked or unchecked.
A single checkbox usually asks a "yes" or "no" question.  Sets of checkboxes
are also seen in to-do lists. !{:margin_left => 100}man-ele-check.png!

Here's a sample checklist.

{{{
 #!ruby
 Shoes.app do
   stack do
     flow { check; para "Frances Johnson" }
     flow { check; para "Ignatius J. Reilly" }
     flow { check; para "Winston Niles Rumfoord" }
   end
 end
}}}

You basically have two ways to use a check.  You can attach a block to the
check and it'll get called when the check gets clicked.  And/or you can just
use the `checked?` method to go back and see if a box has been checked or not.

Okay, let's add to the above example.

{{{
 #!ruby
 Shoes.app do
   @list = ['Frances Johnson', 'Ignatius J. Reilly',
     'Winston Niles Rumfoord']

   stack do
     @list.map! do |name|
       flow { @c = check; para name }
       [@c, name]
     end

     button "What's been checked?" do
       selected = @list.map { |c, name| name if c.checked? }.compact
       alert("You selected: " + selected.join(', '))
     end
   end
 end
}}}

So, when the button gets pressed, each of the checks gets asked for its status,
using the `checked?` method.

You can also set a default `checked` value.

{{{
#!ruby
Shoes.app do
   flow { check; para "Default check (unchecked)" }
   flow { check checked: false; para "Unchecked check" }
   flow { check checked: true; para "Checked check" }
end
}}}

Button methods are listed below, but also see the list of [[Common]] methods,
which all elements respond to.

=== checked?() » true or false ===

Returns whether the box is checked or not.  So, `true` means "yes, the box is checked!"

=== checked = true or false ===

Marks or unmarks the check box.  Using `checked = false`, for instance,
unchecks the box.

=== click() { |self| ... } » self ===

When the check is clicked, its `click` block is called.  The block is handed
`self`, which is the check object which was clicked.

Clicks are sent for both checking and unchecking the box.

=== focus() » self ===

Moves focus to the check.  The check will be highlighted and, if the user hits
Enter, the check will be toggled between its checked and unchecked states.

== EditBox ==

Edit boxes are wide, rectangular boxes for entering text.  On the web, they
call these textareas.  These are multi-line edit boxes for entering longer
descriptions.  Essays, even! !{:margin_left => 100}man-ele-editbox.png!

Without any other styling, edit boxes are sized 200 pixels by 108 pixels.  You
can also use `:width` and `:height` styles to set specific sizes.

{{{
 #!ruby
 Shoes.app do
   edit_box
   edit_box :width => 100, :height => 100
 end
}}}

Other controls (like [[Button]] and [[Check]]) have only click events, but both
[[EditLine]] and EditBox have a `change` event.  The `change` block is called
every time someone types into or deletes from the box.

{{{
 #!ruby
 Shoes.app do
   edit_box do |e|
     @counter.text = e.text.size
   end
   @counter = strong("0")
   para @counter, " characters"
 end
}}}

Notice that the example also uses the [[EditBox.text]] method inside the block.
That method gives you a string of all the characters typed into the box.

More edit box methods are listed below, but also see the list of [[Common]]
methods, which all elements respond to.

=== change() { |self| ... } » self ===

Each time a character is added to or removed from the edit box, its `change`
block is called. The block is given `self`, which is the edit box object which
has changed.

=== focus() » self ===

Moves focus to the edit box. The edit box will be highlighted and the user will
be able to type into the edit box.

=== text() » self ===

Return a string of characters which have been typed into the box.

=== text = a string ===

Fills the edit box with the characters of `a string`.

=== append = a string ===

Appends `a string` to the end of the current contents of the edit_box. 
If you need a newline then you'll have to add it to `a string`

This method appeared in Shoes 3.2.25 and may not be available in Shoes 4.

=== scroll_to_end ===

Scrolls the end_box so the last line is showing. If you are appending strings
to the end and want to show them when they scroll out of view, then you
would want to use this method.

{{{
 #!ruby
 Shoes.app height: 400, width: 640 do
  stack do
    @tb = edit_box "foo", width: 0.8
    @tb.text = "Not your everyday edit_box\n"
    cnt = 0
    button "append" do
      cnt = cnt + 1
      @tb.append("append line #{cnt}\n")
      @tb.scroll_to_end
      #puts "text is: #{@tb.text}"
    end
    button "check" do
      confirm @tb.text
    end
  end
end
}}}

This method appeared in Shoes 3.2.25 and may not be available in Shoes 4.

=== styles ===

Shoes 3.3.6 allows you to set the font and stroke but you may find cross platform
problems when you do that. Not really a good thing to do so don't depended on it and YMMV
(your milage may vary). This works fine on OSX and not so well on Linux and Windows:

{{{
 #!ruby
Shoes.app height: 500, width: 300 do
  stack do
    flow do
      para "Normal "
       @eb1 = edit_box "Normal", tooltip: "normal"
    end
    flow do 
      para "Font  "
      @eb2 = edit_box "Font Is?", font: "Monaco 9", tooltip: "monaco 9"
    end
    flow do
      para "Stroke "
      @eb3 = edit_box "Stroke", stroke: red, tooltip: "red"
    end
    flow do
      para "Both   "
      @eb4 = edit_box "Font and Stroke", font: "Monaco 14", stroke: green,
        tooltip: "14pt fixed & green"
    end
    flow do
      button "Append to" do
        @eb1.append "\nAppended"
        @eb2.append "\nAppended"
        @eb3.append "\nAppended"
        @eb4.append "\nAppended"
      end
      button "change all" do
        @eb1.text = "I've been reset1"
        @eb2.text = "I've been reset1"
        @eb3.text = "I've been reset1"
        @eb4.text = "I've been reset1"
      end
    end
  end
end
}}}

== EditLine ==

Edit lines are a slender, little box for entering text. While the EditBox is
multi-line, an edit line is just one. Line, that is. Horizontal, in fact.
!{:margin_left => 100}man-ele-editline.png!

The unstyled edit line is 200 pixels wide and 28 pixels wide. Roughly. The
height may vary on some platforms.

{{{
 #!ruby
 Shoes.app do
   stack do
     edit_line
     edit_line :width => 400
   end
 end
}}}

You can change the size by styling both the `:width` and the `:height`.
However, you generally only want to style the `:width`, as the height will be
sized to fit the font. (And, in current versions of Shoes, the font for edit
lines and edit boxes cannot be altered anyway.)

If a block is given to an edit line, it receives `change` events. Check out the
[[EditBox]] page for an example of using a change block. In fact, the edit box
has all the same methods as an edit line. Also see the list of [[Common]]
methods, which all elements respond to.

=== change() { |self| ... } » self ===

Each time a character is added to or removed from the edit line, its `change`
block is called. The block is given `self`, which is the edit line object which
has changed. 

=== focus() » self ===

Moves focus to the edit line. The edit line will be highlighted and the user
will be able to type into the edit line.

=== finish() { |self| ...} » self ===

This is called when the enter key (or return key) is pressed in an edit line control
It might be useful if you want a search box when something has to happen when
the enter key is pressed.  Think of it as a 'click' on a hidden button.

It's separate from 'change' event: 

{{{
 #!ruby
 Shoes.app do
  stack do
    @el = edit_line do |e|
      para e.text+"\n"
    end
    @el.finish = proc { |slf| para "enterkey #{slf.text}\n" }
  end
 end
}}}


This only works on Shoes 3.2 and is not in Shoes 4.

=== text() » self ===

Return a string of characters which have been typed into the box.

=== text = a string ===

Fills the edit line with the characters of `a string`.

=== styles ===

Shoes 3.3.6 added the ability to set the font and stroke color. There are
many good reasons `not to do this` if you care about cross platform compatibilty.
It `does not` play nice with any themes your user may have chosen. It won't work
everywhere....

{{{
 #!ruby
Shoes.app height: 300, width: 300 do
  stack do
    flow do
      para "Normal "
       @el1 = edit_line "Normal", tooltip: "Normal"
    end
    flow do 
      para "Font  "
      @el2 = edit_line "Font Is?", font: "Monaco 9", tooltip: "monaco 9"
    end
    flow do
      para "Stroke "
      @el3 = edit_line "Stroke", stroke: red, tooltip: "red"
    end
    flow do
      para "Both"
      @el4 = edit_line "Stroke and Font", stroke: green, font: "Arial 14",
       tooltip: "green arial 14"
    end
    button "change contents" do
      @el1.text = "Changed!"
      @el2.text = "Changed!"
      @el3.text = "Changed!"
      @el4.text = "Changed!"
    end
  end
end
}}}

== Image ==

An image is a picture in PNG, JPEG or GIF format. Shoes can resize images or
flow them in with text. Images can be loaded from a file or directly off the
web. !{:margin_left => 100}man-ele-image.png!

To create an image, use the `image` method in a slot:

{{{
 #!ruby
 Shoes.app do
   para "Nice, nice, very nice.  Busy, busy, busy."
   image "#{DIR}/static/shoes-manual-apps.png"
  end
}}}

When you load any image into Shoes, it is cached in memory. This means that if
you load up many image elements from the same file, it'll only really load the
file once.

You can use web URLs directly as well.

{{{
 #!ruby
 Shoes.app do
   image "http://shoesrb.com/img/shoes-icon.png"
 end
}}}

When an image is loaded from the web, it's cached on the hard drive as well as
in memory. This prevents a repeat download unless the image has changed. (In
case you're wondering: Shoes keeps track of modification times and etags just
like a browser would.)

Sometimes, you don't want Shoes to cache images. For just one particular image
just add add  'cache: false' 

{{{
 #!ruby
 Shoes.app do
   image "http://shoesrb.com/img/shoes-icon.png", cache: false
 end
}}}

You can also disable all image caching - see [[AppMethods]]

Shoes may load remote images in the background using system threads. So,
using remote images may not block Ruby or any intense graphical displays you
may have going on. May not. Assume you'll wait.

=== full_height() » a number ===

The full pixel height of the image. Normally, you can just use the
[[Common.height]] method to figure out how many pixels high the image is. But
if you've resized the image or styled it to be larger or something, then
`height` will return the scaled size.

The `full_height` method gives you the height of image (in pixels) as it was
stored in the original file.

=== full_width() » a number ===

The full pixel width of the image. See the [[Image.full_height]] method for an
explanation of why you might use this method rather than [[Common.width]].

=== path() » a string ===

The URL or file name of the image.

=== path = a string ===

Swaps the image with a different one, loaded from a file or URL.
 
=== rotate(degrees: a number) » self ===

See [[Art.rotate]] on Shapes for details. 
Note that unike Shapes one could call the method also directly on Images.

{{{
#!ruby
Shoes.app do
    img = image "#{DIR}/static/man-ele-image.png", left: 70, top: 60
    img.rotate 45
end
}}}

=== scale(sx: a float, sy: a float) » self ===

See [[Art.scale]] on Shapes for details. 
Note that unike Shapes one could call the method also directly on Images.

{{{
#!ruby
Shoes.app do
    img = image "#{DIR}/static/man-ele-image.png", left: 70, top: 60
    img.scale 1.2, 0.8
end
}}}

=== skew(sx: a float, sy: a float) » self ===

See [[Art.skew]] on Shapes for details. 
Note that unike Shapes one could call the method also directly on Images.

{{{
#!ruby
Shoes.app do
    img = image "#{DIR}/static/man-ele-image.png", left: 70, top: 60
    img.skew 7.5, 9.5
end
}}}



==== Image effects on image blocks ====

You already know how to combine shapes into an image block (See [[Rules]] >> Image and Shape Blocks), using the same technique you can add some effects to those image blocks, namely : blur, shadow and glow, with the help of corresponding methods.
Just wrap shapes or images into an image block and add effects inside the block 

{{{
#!ruby
Shoes.app :width => 400, :height => 450, :resizable => true do
    image :top => 20, :left => 20 do
        fill "#127"
        nostroke
        oval 80, 40, 200, 50
        blur 3
        glow 10, fill: rgb(0.8, 0.4, 0, 0.9)
        glow 10, inner: true, fill: rgb(0.8, 0.4, 0, 0.9)
        shadow radius: 20, fill: rgb(0, 0, 0, 0.75), displace_left: -20, displace_top: 30
    end
    
    image :width => 700, :height => 500, :top => 180, :left => 20 do
        image "#{DIR}/static/app-icon.png", :top => 40, :left => 60
        glow 10, inner: true, fill: yellow
        shadow radius: 10, fill: rgb(0, 0, 0, 0.75), displace_left: -10, displace_top: 10
    end
end
}}}

Pay attention to some rules :

 * Effects are using the alpha channel of your image if any.
 * Shadow effect must be the last one applied to be predictable.
 * For effects to work correctly you can mix shapes with shapes and images with images but not shapes with images !
 * If you experience some artifacts or glitches, that's certainly because your effect doesn't have enough "room" to work correctly ! Try to make your image block bigger and/or move your inside shape/image towards the center of the image block (the idea is to make room for your effect to expand nicely), ultimately you can also decrease the "strength" of the effect (meaning decrease the radius attribute value).

=== blur(radius: a number)  ===
Blurs the image by `radius` amount.

=== glow(radius: a number, :inner  false or true)  ===
Adds a glow to your image, either outer glow (default) or inner glow (set optional `:inner` style to true), amount of glow is set by `radius` attribute.

Note that you can control the color of the effect with the `:fill` style and the transparency of the effect with the alpha component of the color, ie : rgb(red, green, blue, '''alpha''').

=== shadow(distance: a number, radius: a number)  ===
Adds a shadow to your image, `distance` sets the placement of the shadow along a line going from top-left corner to bottom-right corner, the biggest the attribute the more distant the shadow, blurriness of the shadow is controlled by the `radius` attribute.

If you need more precise placement, the method offers two styles for that : `:displace_left` and `:displace_top`, if used they take precedence over the `distance` attribute.

Note that you can control the color of the effect with the `:fill` style and the transparency of the effect with the alpha component of the color, ie : rgb(red, green, blue, '''alpha''').

== ListBox ==

List boxes (also called "combo boxes" or "drop-down boxes" or "select boxes" in
some places) are a list of options that drop down when you click on the box.
!{:margin_left => 100}man-ele-listbox.png!

A list box gets its options from an array.  An array (a list) of strings,
passed into the `:items` style.

{{{
 #!ruby
 Shoes.app do
   para "Choose a fruit:"
   list_box :items => ["Grapes", "Pears", "Apricots"]
 end
}}}

So, the basic size of a list box is about 200 pixels wide and 28 pixels high.
You can adjust this length using the `:width` style.

{{{
 #!ruby
 Shoes.app do
   para "Choose a fruit:"
   list_box :items => ["Grapes", "Pears", "Apricots"],
     :width => 120, :choose => "Apricots" do |list|
       @fruit.text = list.text
   end

   @fruit = para "No fruit selected"
 end
}}}

Next to the `:width` style, the example uses another useful option. The
`:choose` option tells the list box which of the items should be highlighted
from the beginning. (There's also a [[ListBox.choose]] method for highlighting
an item after the box is created.)

List boxes also have a [[ListBox.change]] event. In the last example, we've got
a block hooked up to the list box. Well, okay, see, that's a `change` block.
The block is called each time someone changes the selected item.

Those are the basics. Might you also be persuaded to look at the [[Common]]
methods page, a complete list of the methods that all elements have?

There is also a much reguested option introduced in Shoes 3.3.0 that
allows you to specify the font to be used when you create the list_box.
The string you give is not as flexible as the textblock options for font handling
mention in Styles.  Experiment. For example a simple font: "6" does work for setting the 
size of the default font. 

List_box will also accept the wrap style. 

Note: the font and wrap styles does nothing on OSX because OSX handles long list_box
items much better than Linux or Windows. 

{{{
#!ruby
 Shoes.app :width => 400, :height => 100 do
 stack do
   items = []
   items[0]= "No! Don't tell me"
   items[1]= "Let me tell you a story about how octal numbers fell out of \
favor and were replaced with hexidecimal numbers."
   list_box :items => items, :choose => items[1], font: "Sans Bold 6"
  end
 end
}}}


=== change() { |self| ... } » self ===

Whenever someone highlights a new option in the list box (by clicking on an
item, for instance,) its `change` block is called. The block is given `self`,
which is the list box object which has changed.

=== choose(item: a string) » self ===

Selects the option in the list box that matches the string given by `item`.

=== focus() » self ===

Moves focus to the list box. The list box will be highlighted and, if the user
hits the up and down arrow keys, other options in the list will be selected.

=== items() » an array of strings ===

Returns the complete list of strings that the list box presently shows as its options.

=== items = an array of strings ===

Replaces the list box's options with a new list of strings.

'''Caution!''' You can manipulate Ruby Arrays in many ways that Shoes '''will not''' detect
and Shoes will not display the updated array. For example '<<' will not update
what Shoes displays. += will work because it just happens to be like 
items = . 

When changing the list box from a Shoes program, always copy the
items to a new array, manipulated that and then set the items = new_array

=== text() » a string ===

A string containing whatever text is shown highlighted in the list box right
now. If nothing is selected, `nil` will be the reply.

=== sytles ===

Shoes 3.3.6 adds the ability to set the font and stroke color. `Beware!` This is
highly platform dependent - it doesn't work `at all` with OSX and probably never will.

{{{
#!ruby
Shoes.app height: 200, width: 300 do
  stack do
    flow do
      para "Normal "
      list_box :items => ["one", "two", "three"], choose: "two", tooltip: 
        "normal combo"
    end
    flow do 
      para "Font  "
      list_box items: ["Alpha", "Bravo", "Charlie"], font: "Monaco 9",
        choose: "Bravo", tooltip: "monaco 9 font"
    end
    flow do
      para "Stroke "
      list_box items: ["Ask", "your", "mother!"], choose: "your", stroke: red,
        tooltip: "stroke red"
    end
  end
end
}}}

== Progress ==

Progress bars show you how far along you are in an activity. Usually, a
progress bar represents a percentage (from 0% to 100%.) Shoes thinks of
progress in terms of the decimal numbers 0.0 to 1.0. !{:margin_left => 100}man-ele-progress.png!

A simple progress bar is 200 pixels wide, but you can use the `:width` style
(as with all Shoes elements) to lengthen it.

{{{
#!ruby
 Shoes.app do
   stack :margin => 0.1 do
     title "Progress example"
     @p = progress :width => 1.0

     animate do |i|
       @p.fraction = (i % 100) / 100.0
     end
   end
 end
}}}

Take a look at the [[Common]] methods page for a list of methods found an all
elements, including progress bars.

=== fraction() » a decimal number ===

Returns a decimal number from 0.0 to 1.0, indicating how far along the progress bar is.

=== fraction = a decimal number ===

Sets the progress to a decimal number between 0.0 and 1.0.

== Radio ==

Radio buttons are a group of clickable circles. Click a circle and it'll be
marked. Only one radio button can be marked at a time. (This is similar to the
ListBox, where only one option can be selected at a time.) !{:margin_left => 100}man-ele-radio.png!

So, how do you decide when to use radio buttons and when to use list boxes?
Well, list boxes only show one highlighted item unless you click on the box and
the drop-down appears. But radio buttons are all shown, regardless of which is
marked.

Radios have been rewritten and the rules clarified: You want to use the group 
arguement for radios. Group names are unique to the App (a window) and not the slot 
as previously versions of Shoes tried (and failed). Radios without a group name
act like checkboxes and may not be unselectable. You really want to use a group name!
Further, radios in a group do not have a default button selected (particularly on osx) so 
you should always designate one of them as 'checked'


Here is three radios w/o a group name.
{{{
 #!ruby
 Shoes.app do
   stack do
     para "Among these films, which do you prefer?"
     flow { radio; para "The Taste of Tea by Katsuhito Ishii" }
     flow { radio; para "Kin-Dza-Dza by Georgi Danelia" }
     flow { radio; para "Children of Heaven by Majid Majidi" }
   end
 end
}}}

This can be fixed, though. You can group together radios from different slots,
you just have to give them all the same group name.

Here, let's group all these radios in the `:films` group. Note how the 
second item is set to checked.

{{{
 #!ruby
 Shoes.app do
   stack do
     para "Among these films, which do you prefer?"
     flow do
       radio :films
       para "The Taste of Tea by Katsuhito Ishii"
     end
     flow do
       radio :films, checked: true
       para "Kin-Dza-Dza by Georgi Danelia"
     end
     flow do
       radio :films
       para "Children of Heaven by Majid Majidi"
     end
   end
 end
}}}

For more methods beyond those listed below, also look into the [[Common]]
methods page. Because you get those methods on every radio as well.

=== checked?() » true or false ===

Returns whether the radio button is checked or not. So, `true` means "yes, it
is checked!"

=== checked = true or false ===

Marks or unmarks the radio button. Using `checked = false`, for instance,
clears the radio.

=== click() { |self| ... } » self ===

When the radio button is clicked, its `click` block is called. The block is
handed `self`, which is an object representing the radio which was clicked.

Clicks are sent for both marking and unmarking the radio.

=== focus() » self ===

Moves focus to the radio. The radio will be highlighted and, if the user hits
Enter, the radio will be toggled between its marked and unmarked states.

== Shape ==

A shape is a path outline usually created by drawing methods like `oval` and
`rect`. !{:margin_left => 100}man-ele-shape.png!

See the [[Common]] methods page.  Shapes respond to all of those methods.

== Slider ==

Sliders allows you to adjust a value, from 0.0 to 1.0, thanks to the handle that can be moved with the mouse or by using the arrow keys. !{:margin_left => 100}man-ele-slider.png!

here's a sample showing you a slider in action :

{{{
 #!ruby
Shoes.app do
    stack margin: 10 do
        flow do
            @sl = slider fraction: 0.35, state: nil do |sd|
                @p.text = "value : #{sd.fraction}"
            end
            @p = para "", margin_left: 10
        end
        button "switch slider state" do
            @sl.state = (@sl.state == "disabled" ? nil : "disabled")
        end
    end
end 
}}}

For more methods beyond those listed below, also look into the [[Common]]
methods page. Because you get those methods on every slider as well.

=== fraction() » a decimal number ===

Returns a decimal number from 0.0 to 1.0, depending on how far along the slider bar we are.

=== fraction = a decimal number ===

Sets the slider to a decimal number between 0.0 and 1.0.

=== state » a string ===

See [[Styles.state]] style for details.

=== state = nil, "disabled" or "readonly" ===

See [[Styles.state]] style for details.

== Spinner ==

A Spinner is a widget that allows you display the "I'm busy" rotating 
animated wheel-of-slow !{:margin_left => 100}man-ele-spinner.png!

Here is a sample spinner:
{{{
#!ruby
Shoes.app(width: 200, height: 80) do
   stack left: 60, top: 20 do
      spinner width: 80, start: true, tooltip: "waiting for something?"
   end
end
}}}

Spinner methods are listed below, but also see the list of [[Common]] methods,
which all elements spinner may respond to. The default for a spinner is too
not aninamte (spin). 

Caution: In OSX, this is not a native control so it won't have a tooltip

=== started? » true or false ===

Returns either true or false whether the `spinner` element is started or stopped.

{{{
#!ruby
Shoes.app do
   @s = spinner width: 80
   
   click do |btn, left, top|
      @s.started? ? @s.stop : @s.start
      @p.text = @s.started?
   end
   
   @p = para
end
}}}

=== start() » self ===

Start a `spinner` element.

=== stop() » self ===

Stop a `spinner` element.

=== tooltip() » a string ===

Returns a string containing the tooltip text from a `spinner` element.

{{{
#!ruby
Shoes.app do
   spinner tooltip: "Not spinning enough?"
end
}}}

=== tooltip = a string ===

Set the tooltip text from a `spinner` element with the given string.

{{{
Shoes.app(:width => 450, :height => 250) do
   @s = spinner start: true
   
   every(1) do |count|
      @s.tooltip = "count #{count}"
   end
end
}}}

== Svg ==

In Shoes 3.3 we gained the ability to draw svgs. While they may appear to
look like Images, and they respond to many methods that Images respond to, 
they are not the same. It's a different widget with its own rules, some of
them may be quite surprising.

Svg's are xml text files that contain vector grapic drawing instructions.
They don't really have heights and widths. They can stretch or shrink in
any direction. They also have a feature they call 'groups' An Svg file can contain
sub images in it. The best example is a deck of playing cards.  'paris.svg' 
We include the card deck 'paris.svg' in the Shoes samples directory. 
Without a group name it's a large picture of all cards. Each card in the svg file
has a group name. 

Before you can make use of an svg file. You need to learn what's in it
and what you want to do with it (in total or by group). Shoes can help you
much with that task. Inkscape is a cross platform, free application that
you can use to view, change and create svg's. It's not for beginners but
it's the best you can find for free. 

In order to get Svgs working in Shoes and be Shoes compatible you have to
specify the height and width (and the source ) There two samples in the good
section of the furthermore->samples that you should study good-svgview and good-flip


=== svg  source {width: integer, height: integer, options} ===

You have to specify the width and height you want. There is no default.
Those are the size of the SVG widget on screen in pixels

`source` is a file pathname to the svg or a string containing the svg xml or
an svghandle. Svghandle is a bit weird for the casual Shoes user (see [[Svghandle]])

{{{
Shoes.app do
   svg "#{DIR}/samples/paris.svg"
end
}}}

The hash has some other `options`:

`:group => string`

This how you pick one group from the larger svg to display The string starts with '#'  
so in a svg of playing cards for example you might want to draw '#diamond_queen'
That is the group name. Shoes can not figure out the group names for you. Sorry. 
If you don't specify a ':group' then Shoes draws everything in the svg which may
or may not be what you want.

{{{
Shoes.app do
   svg "#{DIR}/samples/paris.svg", group: "#diamond_queen"
end
}}}

`:aspect => boolean or float`

The aspect may be "true" or "false".  The default is "true"
and that will keep the aspect ratio of the svg (group) even if that means
the image width or height is scaled down to fit the widget size. "false" just fills the rectangle
for the svg widget (stretching width and height as needed) 

Aspect can also be a floating point number.  Advanced users.

Any left over white space after computing the aspect will be added be on the right 
or bottom side. Generally, you should know before you create an svg what size
you want it to be and accept the aspect default. Then you'll have no excess 
white space to think about.

Svg has many of the methods of Image or other controls aka widgets. These 
include `remove, move, displace, hide, show, toggle, hidden?, click, release,
hover, leave, parent, top, left, width, and height`.

Below are the new or diffent methods for Svg, and we mention methods that
exist that you should not use or use with extreme caution.

=== style(styles) » styles ===

Changes the style of an svg.  This could include the `:width` and `:height`
of an svg or any other number of style settings.

Warning: this may return a copy of the xml in the `content:` style which is not 
something you want to do. Don't try to set `content:` this way. 

=== preferred_width » a number ===

returns the width of the internal svg. This can be more or less than what width
returns. You probably don't want to use this method.

=== preferred_height » a number ===

returns the height of the internal svg. This can be more or less than what height
returns. You probably don't want to use this method.

=== offset_x » a number ===

For experts working with groups. returns the group x offset.

=== offset_y » a number ===

For experts working with groups. returns the group y offset.

=== group? string » boolean ===

return true if the string is a svg group or false (nil) if not. Remember that
you have to have a '#' in the front of the string

=== transform(:center or :corner) » self ===

Behaves like [[Art.transform]].

=== translate(left, top) » self ===

Behaves like [[Art.translate]]

=== rotate(degrees: a number) » self ===

Behaves like [[Art.rotate]].

=== scale(sx: a float, sy: a float) » self ===

Behaves like [[Art.scale]]

=== skew(sx: a float, sy: a float) » self ===

Behaves like [Art.skew]

=== handle » svghandle ===

All Svg widgets have an internal svghandle associated with them, whether
you explicity created one or not. This returns it.

=== handle = svghandle » ===

Replaces the widget contents (on screen drawing) with the new svghandle drawing. 
In some situations this can be much faster than removing an svg widget and
creating a new svg widget.  Advanced users.

=== dpi » a number ===

returns the dots per inch of the svg. Expect a constant value of 72.0 or 75.0 no matter
what. Probably useless. 

===  export {filename: "...", dpi: 90, canvas: true||false}  ===

This creates a raster (png only) file for the filename: . The `dpi:` setting
is optional (and useless at this time). The `canvas:` setting controls
what's written. If `canvas: true`, then the on screen image is written as
is seen which includes any transparent space on the bottom or right. If the
`canvas: false` is chosen (it's the default) then only the visible part of
the svg image is written. 

`Note` the filename `is not parsed` for the extention to determine if there
is a .png at the end

=== save {filename: "...", format: "svg"|"ps"|"pdf", canvas: true||false| ===

This saves the onscreen svg to the vector formats of ps, pdf, or svg as specified in the :format 
setting in the hash. The filename `is not parsed` for the extention to determine
what format to use when creating the file.

If `canvas: true`, then the on screen image is written as
is seen which includes any transparent space on the bottom or right. If the
`canvas: false` is chosen (it's the default) then only the visible part of
the svg image is written.

`Note:` When creating an svg file from a svg group this will can create an
svg file that is quite small (or quite larger) which may not pass muster for
strict svg parsing. 

== Switch ==

Switch are clickable buttons that can be either on or off. They are fantastic
for your configuration panel. !{:margin_left => 100}man-ele-switch.png!

Here is a sample switch:
{{{
#!ruby
Shoes.app do
   switch; para "turn on and off"
end
}}}

Switch methods are listed below, but also see the list of [[Common]] methods,
which all elements respond to.

=== active? » true or false ===

Returns either true or false whether the `switch` element is turned on or off.

{{{
#!ruby
Shoes.app do
   switch.click do |n|
      @p.text = n.active?
   end
   @p = para
end
}}}

=== active = true or false ===

Turn on or off a `switch` element.

{{{
#!ruby
Shoes.app do
   @s = switch
   
   every(1) do
      @s.active = @s.active? ^ true
   end
end
}}}

=== click() { |self| ... } » self ===

When the switch is clicked, its `click` block is called.  The block is handed
`self`, which is the switch object that was clicked.

{{{
#!ruby
Shoes.app do
   switch.click do |n|
      alert "switch box clicked, active? #{n.active?}"
   end
end
}}}

Clicks are sent for both switching on and off.

=== tooltip() » a string ===

Returns a string containing the tooltip text from a `switch` element.

{{{
#!ruby
Shoes.app do
   switch tooltip: "Turn the switch on or off" do |n|
      @p.text = n.tooltip
   end
   @p = para
end
}}}

=== tooltip = a string ===

Set the tooltip text from a `switch` element with the given string.

{{{
#!ruby
Shoes.app(:title => "Switching On and Off", :width => 450, :height => 250) do
   switch do |n|
      n.tooltip = "Switch is active? #{n.active?}"
   end
end
}}}

=== font styling ===

With Shoes 3.3.6, switch can also change fonts and the font color (stroke)

{{{
#!ruby
Shoes.app do
   flow do
      switch font: "monospace Italic 16", stroke: red; para
   end
   
   flow do
      @n = switch(active: true) do
         @p.text = (@n.active? ? "true": "false") unless @p.nil?
      end
      @p = para
   end
   
   flow do
      @m = switch width: 80
      @m.click do
        #$stderr.puts "Click"
        @m.active? ? @e.start : @e.stop
      end
      @e = every(1) { |count| @q.text = count unless @q.nil? & @m.active? }
      @q = para ""
   end
   
   start do
      @e.stop
      @p.text = @n.active? ? "true" : "false"
      @m.active = false
   end
end
}}}

== Snapshot ==

Shoes can draw an image block into a file instead of on the screen by calling
the snapshot method. The file can be svg, ps, or pdf. 

It's also possible to see it on the screen in certain situations 
You'll have to decide if thats a bug or feature.

=== snapshot(:format => a type of image, :filename => a path) {...} » snapshot raw data ===

:format could be a svg (default), pdf or ps (it's also the extension of your saved snapshot).

:filename is the path to the file where you save your snapshot (defaults to same filename in same directory as your script file with the choosen extension).

Inside the block you build the image/snapshot you want to end up with :

{{{
#!ruby
Shoes.app width: 400, height: 400 do 
    ext = "svg"
    ext = "pdf"
    path = "#{LIB_DIR}/snapshotfile.#{ext}"
     
    stack do    
        button("shoot!") do
            r = snapshot :format => ext.to_sym, :filename => path  do
                stroke blue
                strokewidth 4
                fill black
                oval 100, 100, 200
            end
            info r.inspect
            alert path, title: "snapshot saved to :"
            Shoes.show_log
            para "Done" # comment this out and the svg does not show
        end
    end
end 
}}}

note that the method returns the drawing code (text) of the snapshot, so 
you might take further control about details of your svg image for example.

== Systray ==

Systray allows you to send an icon and a text message to the desktop manager
which will be shown where the platform decides it should be (systray for Windows),
Notification area for Linux and OSX. Typically, you would call it for some
long running process, like a email client that got a new message and you the desktop
to know about it.

This is not a widget you can modify. There are no methods other than creating it
and that will return nil (even when it works). There is no guarantee it will work,
particularly if you call it too often and expect everything to show up. That's up to
the OS and Desktop manager, not Shoes. 

You can call it in two ways, with positional arguments or with a hash of arguments.


=== systray <string>, <string>, <string> » nil ===

The first string is the title, the second is the message to display and the
third string is a file path to the icon. The example below describes the preferred
way

=== systray title: <string>, message: <string>, icon: <file path> » nil ===

You can also use a hash of arguments.  The example below is worth some study.
{{{
#!ruby
Shoes.app do
  stack do
    para "Press button and look in your system's notification area"
    ctr = 0;
    button "Notify" do
      ctr += 1
      icp = ''
      if ctr % 3 != 0
        icp = "#{DIR}/static/shoes-icon.png"
      else
        icp = "#{DIR}/static/shoes-icon-red.png"
      end
      systray title: "Shoes Notify", message: "message ##{ctr}", icon: icp
    end
  end 
end
}}}

Notice how we change the message: and every third click, the icon changes.
Changes to the title: may not appear, depending on your platform so you
not change change it. All three arguments must be included. 

== TextBlock ==

The TextBlock object represents a group of text organized as a single element.
A paragraph containing bolded text, for example. A caption containing links and
bolded text. (So, a `caption` is a TextBlock type.  However, `link` and
`strong` are TextClass types.) !{:margin_left => 100}man-ele-textblock.png!

All of the various types of TextBlock are found on the [[Element Element Creation]] page.

 * [[Element.banner]], a 48 pixel font.
 * [[Element.title]], a 34 pixel font.
 * [[Element.subtitle]], a 26 pixel font.
 * [[Element.tagline]], an 18 pixel font.
 * [[Element.caption]], a 14 pixel font.
 * [[Element.para]], a 12 pixel font.
 * [[Element.inscription]], a 10 pixel font.

=== contents() » an array of elements  ===

Lists all of the strings and styled text objects inside this block.

=== replace(a string) ===

Replaces the text of the entire block with the characters of `a string`.

=== text() » a string ===

Return a string of all of the characters in this text box. This will strip off
any style or text classes and just return the actual characters, as if seen on
the screen.

=== text = a string ===

Replaces the text of the entire block with the characters of `a string`.

=== to_s() » a string ===

An alias for [[TextBlock.text]]. Returns a flattened string of all of this
TextBlock's contents.

== Timers ==

Shoes contains three timer classes: the Animation class, the Every class and
the Timer class. Both Animations and Everies loop over and over after they
start.  Timers happen once. A one-shot timer.

Animations and Everies are basically the same thing. The difference is that
Animations usually happen many, many times per second. And Everies happen only
once every few seconds or rarely.

=== start() » self ===

Both types of timers automatically start themselves, so there's no need to use
this normally. But if you [[Timers.stop]] a timer and would like to start it up
again, then by all means: use this!

=== stop() » self ===

Pauses the animation or timer. In the case of a one-shot timer that's already
happened, it's already stopped and this method will have no effect.

=== toggle() » self ===

If the animation or timer is stopped, it is started. Otherwise, if it is
already running, it is stopped.

== Video ==

Shoes 3.3.1 restores the old Video widget capabilies. But differently for
those who remember the old ways: You can't package your app with the VLC libraries included. 
There is no separate video/non-video version of Shoes. There are no buttons
or links created for you. 

What Shoes does is to look for VLC installed on the running system and if its a recent
enough version of VLC (2.1, 2,2) then Shoes will use it. This has implications for
folks that write scripts for other people:  Those end users will have to install
VLC from videolan.org, and they should install it in the default place that
VLC suggests, because thats where Shoes will look.  If you are just write Shoes code
for yourself you also need to install VLC, just like anybody else.

Shoes looks for VLC in /usr/lib (for linux), /Applications/VLC.app (osx) and
C:\"Program Files (x86)"\VideoLAN\VLC which is where VLC installs it's self.

You also have to draw your own buttons or links and hook them up so they 
call the methods to pause, play, fast forward and so on. Take a look at the
expert-video-player in Furthermore->Samples which is tour-de-force of how to create a 
custom widget and wire up. We might get an easier method built in the future but 
for now, you need to do it the hard way.

To add a video you need to

{{{
require 'shoes/videoffi'
}}}

'''Vlc.load_lib'''

This checks that VLC is installed and makes it's api's available to Shoes.  
This call to '''load_lib''' method is happening transparently when you create a new widget, you don't need it in your scripts.

If Shoes can't find VLC on it's own, and you know you have installed it, you can help Shoes : just go to the Cobbler (you'll find him by clicking on '''Maintain Shoes''' button at the start screen) once in Cobbler's atelier, click on '''VLC setup button''' ...). 

[[BR]]
    '''video(path/url: a string, optional styles) » video-widget''' 

This creates the on screen widget with the styles args like width and height and some unique settings. This is the widget you control with the methods below.

"path/url" is the path to a file or an address of a stream as a String (everything Vlc can read on your hard drive or over the internet, you're pretty much spoilt for choice !), this parameter is mandatory, note that you can pass "" i.e. an empty string, if you want to start with an empty media player and later load a media with path= method (see below).

There are some styles that are unique to Video widgets:

 * `:autoplay` => true or false

Start playing given media immediately and every time you load a new media. You can change this later by means of autoplay= method (see below). Defaults to `false`.

 * `:volume` => integer 0..100

Defaults to `85`.

 * `:bg_color` => a Shoes color

Sets the background of the video area. Defaults to `black`, rgb(0,0,0).

 * `:vlc_options` => an array of String

'''Advanced users !''' Vlc player options, if you really need to customize Vlc ! - you're on your own here, lookup for '''libvlc_new''' arguments -.

One option is worth mentionning, though : "--play-and-pause" [[BR]]
It is related to the '''play_list_add''' method (see below).
Note that, as mentionned in Vlc doc, there is no guaranty about cross-platform implementation or even between vlc release.

[[BR]]
    '''audio(path/url: a string, optional styles) » video-widget'''

Just a convenience method, hiding away the widget. If you need sounds only in your app and don't want a visible widget on screen


=== autoplay() » true or false ===

Checks if Vlc is in autoplay mode.

=== autoplay = true or false ===
 
Sets Vlc autoplay mode.

=== have_audio_track() » true or nil ===

Checks if media have an audio track.

=== have_video_track() » true or nil ===

Checks if media have a video track.

=== hide() » self ===

Hides the video. If already playing, the video will continue to play. This just
turns off display of the video. One possible use of this method is to collapse
the video area when it is playing an audio file, such as an MP3.

=== loaded() » true or nil ===

If you want to check whether Vlc has loaded or not your media.

=== length() » a number ===

The full length of the video in milliseconds. Returns nil if the video is not
yet loaded.

=== move(left, top) » self ===

Moves the video to specific coordinates, the (left, top) being the upper left
hand corner of the video.

=== next_media » true or false ===

When a playlist has been loaded, changes the actual media to the next item in the playlist. Returns true upon success, false if there isn't a next item.

=== path() » a String ===

Returns the path or url of the media actually loaded, empty string if no media have been yet loaded.

=== path= a String ===

Loads a new media into your player, could be a file : video, audio, playlist, image or a stream on the web: from popular video sites, radio, etc... Whatever your Vlc could digest.

=== pause() ===

Pauses the video, if it is playing. To resume playing, call that method again - not the play() method, it will restart from the beginning -.

=== playing?() » true of false ===

Returns true if the video is currently playing. Or, false if the video is
paused or stopped.

=== play() » int ===

Starts playing the video, if it isn't already playing. If already playing, the
video is restarted from the beginning.

=== play_list_add(path : a String) » true of false ===

Adds a new media into the play list. Shoes uses a play list internally, usually there is only one media in it, the one you loaded, but if you want to build a play list dynamically, this is the method you are going to use.

It can be usefull, coupled with the :vlc_options "--play-and-pause", if you want to prepare some media to be played at some point later.[[BR]]
By default a play list keep on playing one media after the other without stopping at the end of one media, that option can change this.[[BR]]
Create a video widget with "--play-and-pause" option, add medias to the play list, use '''play_at''' method to play the desired media at the specified index in the play list.

for example, say you create a game and want some sounds to be played at some events :
{{{
SOUNDS = ["path/to/media1", "path/to/media2", "path/to/media3"]
player = audio '', autoplay: false, vlc_options: ["--play-and-pause"]
SOUNDS.each { |snd| player.play_list_add(snd) }

player.play_at 1 # player.play_at 2 or 0 depending on the event
}}}

=== play_at(idx : an Integer) » true of false ===

Plays the media at index idx in the play list. See '''play_list_add'''.

=== position() » a decimal ===

The position of the video as a decimanl number (a Float) between the beginning
(0.0) and the end (1.0). For instance, a Float value of 0.5 indicates the
halfway point of the video.

=== position = a decimal ===

Sets the position of the video using a Float value. To move the video to its
25% position: `@video.position = 0.25`.

=== previous_media » true or false ===

When a playlist has been loaded, changes the actual media to the previous item in the playlist. Returns true upon success, false if there isn't a previous item.

=== remove() » self ===

Removes the video from its slot. This will stop the video as well.

=== show() » self ===

Reveals the video, if it has been hidden by the `hide()` method.

=== stop() » self ===

Stops the video, if it is playing.

=== time() » a number ===

The time position of the video in milliseconds. So, if the video is 10 seconds
into play, this method would return the number 10000.

=== time = a number ===

Set the position of the video to a time in milliseconds.

=== toggle() » self ===

Toggles the visibility of the video. If the video can be seen, then `hide` is
called. Otherwise, `show` is called.

=== video_track_height() » an number ===

If loaded media has a video track, fetches it's real height. This is not necessarily the height of the widget, because most of the times you gave some dimensions to your widget and Vlc will accomodate for them.

=== video_track_width() » an number ===

If loaded media has a video track, fetches it's real width. See video_track_height() above.

== Plot ==

In Shoes 3.3.2+ you can draw some simple plots or charts or graphs. Line charts,
column charts, scatter charts, pie charts and a variation of Line charts for time series.

A plot widget is a rectangular space on the screen you can place in in a stack
or flow just like any other element. You'll have to specify the height and width in pixels and
then you pass in a hash of options that we'll discuss. Consider this example:

{{{Shoes.app width: 800, height: 500 do
  stack do
    para "Plot Demo Line and Column"
    widget_width = 400
    widget_height = 300
    stack do
      flow do
        @grf = plot widget_width, widget_height, title: "My Graph", caption: 
          "Look at that! Booyah!!" , font: "Helvetica", auto_grid: true,
          default: "skip", background: honeydew
         @grf2 = plot widget_width, widget_height+100, title: "Column Graph", caption: 
          "Amazing!!" , font: "Mono", auto_grid: false, 
          default: "skip", background: cornsilk, chart: "column", boundary_box: false
      end
    end
  end
end
}}}

Click the Run this button and continue reading.

That example doesn't draw any data points! Correct-o-mundo! We have to add them and we'll get to how to
do that soon but there are a bunch of options you want to consider. The most important option is
that chart: <string> and  know that not all options make sense for all chart types. Look closely and you'll notice
that the title string is displayed inside the plot widget. So is the caption string. And there is too much empty
space at the bottom of the widget. 

To draw data inside the plot widget we add another hash to the plot. In this example we
are going to draw two sets of data points and labels into two different chart_types.

{{{
Shoes.app width: 800, height: 500 do
  @values1 = [24, 22, 10, 13, 20, 8, 22]
  @x_axis1 = ['a','b','c','d','e','f', 'g']
  @values2 = [200, 150, 75, 125, 75, 225, 125] 
  @x_axis2 = ['a','b','c','d','e','f', 'g']
  stack do
    para "Plot Demo Line and Column"
    widget_width = 400
    widget_height = 300
    stack do
      flow do
        @grf = plot widget_width, widget_height, title: "My Graph", caption: 
          "Look at that! Booyah!!" , font: "Helvetica", auto_grid: true,
          default: "skip", background: honeydew
         @grf2 = plot widget_width, widget_height+100, title: "Column Graph", caption: 
          "Amazing!!" , font: "Mono", auto_grid: false, 
          default: "skip", background: cornsilk, chart: "column", boundary_box: false
      end
    end
    @grf.add values: @values1, labels: @x_axis1,
      name: "foobar", min: 6, max: 26 , desc: "foobar Yy", color: "dodgerblue",
       points: true
    @grf.add values: @values2, labels: @x_axis2,
       name: "Tab", min: @values2.min, max: @values2.max, desc: "BarTab", color: "coral",
       points: true, strokewidth: 2

    @grf2.add values: @values1, labels: @x_axis1,
       name: "Bar", min: 0, max:  30, desc: "foobar Yy", color: "crimson",
       points: true, strokewidth: 12
    cs2 = chart_series values: @values2, labels: @x_axis2,
       name: "Tab", min: 50, max: 230, desc: "BarTab", color: "green",
       points: true, strokewidth: 6
    @grf2.add cs2
  end
end
}}}

If you look closely, you'll notice most of those add's are the same except the second
add to the column graph creates a chart_series first and then adds that to plot widget.
instead of a hash.

[[Chart_series]] is documented in the Advanced Section of the manual. If you prefer to add a hash
of options, Shoes will create a chart_series for you. We'll discuss the options in this section
with more advanced things in the [[Chart_Series]] section.

Now you know how it all comes together in some kind of complicated dance of options. Some options belong
to a plot and some options belong to one set of data in the plot (aka the chart_series).

=== plot width, height, {options} ===

Creates a plot widget of width, height using the options given. The data inside that rectangle
is auto-sized, auto-scaled to fit as best it can in that rectangle. 

=== chart: <string> ===

String is one of "line", "column", "scatter", "pie", "radar" or "timeseries" This is the type of
chart you want for this plot widget. Timeseries is like "line" except it has extra options
for interacting with very large data sets with hundreds or thousands of data points.

Not all options are used by all chart types. 

=== font: <string> ===

This is the Shoes font name to be used for all text in this plot widget.
You have no control over which point size is used where. Default is "Helvitica" and
if you happen to pick some font that only exists on your machine, Shoes may default
to something you don't want on another machine or OS without that font.

=== title: <string> ===

The string will be drawn, centered, at the top of plot in the chosen font. The point size and style
will be 16 bold.

=== caption: <string> ===

The string will drawn at the bottom of the plot widget as 12 point normal. Do 
not attempt to draw multiple lines captions with a newline in the string. Multiple line 
captions (and titles) won't work so don't do it. 

=== background: <color> ===

color is something in the [[Colors The Colors list]] or the result of calling 
rgb(). The background is for the entire widget space and some plot types may not respect the setting.

=== boundary_box: <boolean> ===

If true then a box is drawn around the inner data area.  Not all chart types
will respect the setting (Pie chart for one won't- doesn't hurt if specified, it just won't
be drawn.

=== auto_grid: <boolean> ===

This another option that is only respected by certain chart types where it makes sense.
(Line, scatter, timeseries and column). 
Draws vertical and horizontal lines at what Shoes thinks would be best for the
data given. 

=== default: <string> ===

This controls how the plot will deal with nils in your data arrays or labels arrays that you 
add to to the plot. The default is "missing", but some chart types will respect "max" and "min"
so a missing value (nil) is set to the maximum or minimum of their range. Usually, this is not
visually helpful and can be confusing or misleading.  If you need this option you should clean up your data or find 
a more competent chart application and not use Shoes for more than your exploratory work. Just Saying"
"A man has got to now his limitations".

=== click: proc {|btn, l, t| } ===

Only (barely) useful and only for TimeSeries charts. If the user clicks in the content area of the
plot, Shoes will call the proc with the button number and the top, left values of the mouse scaled to be in the content
area. Figuring out what to do with that info is very complicated.

=== column_settings: <array> ===

This only used for radar charts and is mandatory. It also requires a long description
and an example.
{{{
# Radar graph - 
Shoes.app width: 620, height: 480 do
  @pre_test =  [71, 35, 62, 55, 88, 76, 55] 
  @practice =  [70, 53, 83, 94, 71, 59, 82]
  @post_test = [94, 93, 96, 89, 96, 88, 93]
  @dimensions = [ ["Anger", 0, 100, "%3.0f%%"], 
               ["Contempt", 0, 100, "%3.0f%%"],
               {label: "Disgust", min: 0, max: 100, format: "%3.0f%%"},
               ["Fear", 0, 100, "%3.0f%%"],
               ["Joy", 0, 100, "%3.0f%%"],
               ["Sadness", 0, 100, "%3.0f%%"],
               ["Surprise", 0, 100, "%3.0f%%"]
             ]
  stack do
    para "Plot Radar Demo 7"
    flow do 
      button "quit" do Shoes.quit end
    end
    widget_width = 600
    widget_height = 400
    stack do
      flow do
        @grf = plot widget_width, widget_height, title: "Microexpressions Scores", 
          font: "Helvetica", auto_grid: true, grid_lines: 3, label_radius: 1.10,
          default: "skip", chart: "radar", column_settings: @dimensions
      end
    end
    @grf.add values: @pre_test, color: blue, 
      name: "Pre-Test Score", min: 0, max: 100, strokewidth: 3
    cs = app.chart_series values: @practice, color: red,
      name: "Practice Score", min: 0, max: 100, strokewidth: 3
    @grf.add cs
    @grf.add values: @post_test, color: orange,
      name: "Post-Test Score", min: 0, max: 100, strokewidth: 3
  end
end
}}}

Run the example and study the code.  For the other chart types, Shoes
processes chart_series like a row in speadsheet. Radar needs column info and
column settings: is how you specify it with an array containing  another array or a hash.
If you look at the hash in the example you'll see old friends like label: min: and max:
format: is not something you may have seen before. It's a Ruby printf control string
that will be given a Ruby double to turn into text.  format: is optional but it
defaults to "4.2f" - four digits on the left of the decimal point and 2 digits to 
the right. 

=== grid_lines: <integer> ===

This is only used for radar charts and is optional. It can be true, false or a number.
The default is true. When true,  Shoes makes it's estimate of how many grid_lines or 'rings'
to draw around before it becomes too busy.  You can override that. False or 0
means none, true or 1 means guess. 3 would mean 3 'rings' and so on. 

=== label_radius: <float_number> ===

This is only used for radar charts and is optional. The labels in the column_setting
are drawn on outside of the circle at the radius * 1.15 (default). This good
for some charts and not so good for others. 1.15 means 15% outside. 1.20 is probably
are high as you can get away with before colliding into the title string. 0.5 would
would move them into the circle - probably not what you want.

=== plot.save_as <filename> ===

This method will draw the plot to an .svg, .pdf ,ps, or .png depending on the extention 
of the filename

=== plot.zoom (begin, end)  ===

This method only works on Timeseries plots (think about thousand of data points).
Remember that you can draw up to 6 data sets (chart_series) in some plot types. 
You can set the beginning and ending indicies (integers) for display. This and the click:
proc and some keypress handling will allow you to zoom in, zoom out, and shift left or right.
It does not change the data. It only affects which part of your data is drawn.

=== plot.redraw_to(index) ===

Timeseries and line plots can be appended to with new data (perhaps you're collecting data
from a sensor or a remote website or some sort of progress starus from a long running process)

This is a plot method!! If your have two or three data sets displayed in one plot widget then
it's up to you to update all of them before calling redraw_to and if your zooming in and appending 
you'll have to figure it out because redraw_to will reset the plot begin to 0 and the end index to the given index which
really should be a new data point.


=== plot.add {options} or chart_series. ===

create s a chart_series for you from the hash arguments. The chart_series
is added to the plot widget. You can only have one series for a Pie chart. 
You must have two and only two for a Scatter graph. Line, timeseries, and bar charts
can have up to 6, but you probably don't want that many in one widget.

The first add to a plot widget controls what is shown on the horizontal x axis. 

Not all chart types respect all chart settings. 

=== plot.add labels: <array> ===

The labels: option is mostly required.  It must be an array of strings. In a few
cases Shoes can create one ["1", "2" ....] but you should not depend on that and you 
don't want that.

=== plot.add values: <array> ===

The values: array must be Ruby numbers and too be safe, they should be positive numbers.
values: and labels: are assummed to have same number of array elements.

=== plot.add min: <number> ===

This controls y axis auto scaling lower tick for this data. Currently, you want this
to be a positive number. This is a required hash arg for most chart types. 
Although you can calulate it with <array>.min you'll usually set your own for visual reasons.

=== plot.add max: <number> ===

This controls y axis auto scaling upper tick for this data. Currently, you want this
to be a positive number. This is a required hash arg for most chart types. 
Although you can calulate it with <array>.max you'll usually set your own for visual reasons.

=== plot.add name: <string> ===

This is a string you can use for what ever makes sense to you. There are methods
to look it up in the plot wdith to get the chart_series.  Required but mostly not all that important to
you. 

=== plot.add desc: <string> ===

This is the string that will show up in the chart legend. Highly recommended.
If you don't provide it, Shoes will use what ever your name: is. 

=== plot.add color: <color> ===

This is color to use to draw this data. It can be one to the built in Shoes colors
or an rgb() color you created. Note: Pie charts ignore this and use there own set of
colors. The first entry for a Scatter Chart uses this for the widget and ignores any color:
in the second series of a scatter.

=== plot.add strokewidth: <integer> ===

This is the width of the line, and/or size of the point. For column charts, it's the width
of the bar. Ignored for Pie charts

=== plot.add points: <int, string or boolean> ===

Only working for scatter charts. Line and Timeseries don't use this (known bug)
and pie & column don't need it. 

Controls what kind of point to draw. I highly recommend you do not specify this and just
accept that ever Shoes thinks. There is a relationship with strokewidth: which probably make
no sense to the beginner.  Even so, here's how it should work.

Each point has a number inside Shoes - 0 or nil or false means don't draw any point markers. 
That can vanishs your drawing in a Scatter and others. Don't use this unless you're feeling extra
clever. 

The default (which is what you want) is true or 1, You get the default point for your chart tyoe. 
Did I mention this is what you want? A Timeseries charts with 1000's of data points will not disply
the point type until you zoom in close enough that Shoes thins it has enough visual space for them to
be useful.

The string can be "dot", "circle", "box", and "rect" and perhaps drawn according to
strokewidth: - or not.  depending on chart type.  "dot" is a filled in "circle". box is a filled in
"rect"

Have we mentioned that the default is what you want?  


= Furthermore =
 Run the samples from here, or read more Shoes information on the Internet. 

== Sample Apps ==

In the Shoes directories are these samples you can run from the manual:

{SAMPLES}

Note: Cobbler (Maintain Shoes) has an option to copy the samples to a directory
of your choice so you can modify them as you like and you won't have to poke around
inside Shoes directories and change something you didn't want to change. 


== Internet Resources ==

Shoes has many Ruby related features that haven't been described here. How can
I learn more?

The opening splash screen hints at the secrets. Packaging and Maintaining? What's that? And
what do all the options and buttons mean when I do run them? Relax, you 
should know that these resources exist. If you're just beginning, feel free 
to click around but it can be a firehose of information. You don't need to know it to
have fun with Shoes. Just know it exists and you can come back here when your ready
to inhale. 


See the [[https://github.com/Shoes3/shoes3/wiki Shoes 3.2 Wiki]] and learn about Gems
and packaging and much more. Find reference links to learning Ruby and more inside Shoes
details.  

 * [[https://github.com/Shoes3/shoes3 Shoes 3.2 source code.]] 
 * You should join the [[http://lists.mvmanila.com/listinfo.cgi/shoes-mvmanila.com Shoes mailing list ]]
 * Bookmark the [[http://walkabout.mvmanila.com/ Shoes 3.2 blog]] or the [[http://walkabout.mvmanila.com/feed/ RSS feed]]
 * Early [[http://shoes.mvmanila.com/public/shoes/ Downloads]] (work in progress) that may not be announced 

Older Shoes Links for historical purposes (may be dead):

 * [[http://librelist.com/browser/shoes/ Old Shoes ML]]  
 * [[http://github.com/shoes/shoes/ Shoes 3.1 Source Code]] is on GitHub.
 * [[http://github.com/shoes/shoes/downloads Recent Builds]] for your platform.

== Shortcuts ==

Shoes provides the following general keyboard shortcuts:

 * `Alt-/` or `⌘-/` opens '''Shoes Console'''.
 * `Alt-.` or `⌘-.` opens '''Open File…''' dialog.
 * `Alt-?` or `⌘-?` opens '''Shoes Manual'''.
 * `Alt-=` or `⌘-=` opens [[IRB '''Shoes Interactive Ruby''']].
 * `Alt-;` or `⌘-;` opens '''Remote byebug server'''.

Shoes Manual provides the following keyboard shortcut:

 * `Alt-f` or `⌘-f` opens '''Search''' section.
 * `Alt-left` or `⌘-left` browses back.
 * `Alt-right` or `⌘-right` browses forward.
 * `PgUp` and `PgDn` scrolls up and down one page.
 * `Up` and `Down` scrolls up and down one line.

Shoes Console provides the following keyboard shortcut:

 * `Alt-t` or `⌘-t` disables autoscroll.

== IRB Interactive Ruby ==

Shoes provides an '''Interactive Ruby''' (IRB) console for quick expression evaluations, fast prototyping and manipulate Shoes objects.

Press `Alt-=` or `⌘-=` to open an Interactive Ruby console.

=== Getting started ===

IRB comes with embedded commands to facilitate your interaction. Type '''help''' in your current session to list all available commands. !{:margin_left => 60}shoes-irb-help.png!

[[http://www.ruby-lang.org/en/documentation/quickstart/ Ruby in Twenty Minutes]] is an excellent tutorial on Ruby and the first 3 pages are focused on IRB. You can type in those examples in your Shoes Interactive Ruby console.

=== Interacting with Shoes ===

Now let's interact with Shoes objects in order to incrementally create the following GUI in a fast prototyping fashion. !{:margin_left => 100}shoes-irb-history-lesson.png!

Type the following code in your IRB console to create a [[App.Shoes.app]] with a specific title and size. The variable '''app''' will contain your newly created window but it is possible to search Shoes apps amongst [[App.Shoes.APPS]]. 

`app = Shoes.app(:title => "History Lesson", :height => 75, :width => 300) {}`

A stack is added to contain the text that will display the historical era. You will notice that simply calling [[Element.para]] in IRB will result in a NoMethodError exception. Para is essentially a method that belongs to a [[Slots]], hence '''app.para''' is used here.

`app.stack { @p = app.para }`

The following creates a [[Element.flow]] allowing buttons to align side-by-side and also the first button. The button is clickable immediately after typing the code below.

`f = app.flow { app.button("1800s") { @p.replace "1800s" } }`

It is possible to manipulate elements in any [[Slots]]. Let's add another historical era to your your flow.

`f.button("1900s") { @p.replace "1900s" }`

Shall we verify that those buttons are indeed part of the flow '''f'''?

`f.contents`

Add another button to fill up some space.

`f.button("2000s") { @p.replace "2000s" }`

You can list your command history and see what you have done so far. It is also possible to save the command history to a file by typing '''save'''. For now, let's just take a look at the command '''history'''.

`history`

Finally, add a last button for entertainment value. You can press '''up''' or '''down''' to navigate through your history until you find the previous button, press '''left''' or '''right''' to edit the values, and press '''enter'''.

`f.button("2100s") { @p.replace "2100s" }`

Your '''Interactive Ruby''' console should look like this: !{:margin_left => 60}shoes-irb-sample.png!



= Advanced =

  Shoes has some features that don't quite fit into the Shoes is easy model.

== AppMethods ==

There are some special methods associated with App that are designed for special situations.
They affect subtle things and big things. They are a bit dangerous if called incorrectly so
experiment wisely if you need the feature. You would want to call these early in your Shoes.app
block. 

Another caution - these are methods of an App instance so you need that object.
Even when they effect more than one instance of App. Shoes creates an 'app'
method in the Shoes.app block that you must use for the following.

=== app.cache » boolean ===

Returns the setting of the app's image caching status.

=== app.cache = boolean ===

Changes the image caching behavior for the whole app. By default, images are 
cached (aka 'true'). Sometimes, that is not desired. You can turn off the caching
for all image calls by setting this to 'false' Note: individual calls to image can
override the global setting - see [[Image]]

=== app.cache_clear sym » boolean  ===

Clears the internal image cache or the external image cache or both depending on the 
symbol provided for the argument - one of :memory, :external, :all

Always returns true. 

=== app.cursor » symbol ===

Returns the cursor symbol currently set for the Window (app). 

=== app.cursor = symbol ===

Sets the cursor to the symbol. The symbols is one of the following: 
`:arrow_cursor`, `:text_cursor`, `:watch_cursor` or `:hand_cursor`.

{{{
Shoes.app do
  stack do
    para "Change cursor to"
    flow do
      button "arrow" do
        app.cursor = :arrow_cursor
      end
      button "text" do
        app.cursor = :text_cursor
      end
      button "watch" do
        app.cursor = :watch_cursor
      end
      button "hand" do
        app.cursor = :hand_cursor
      end
    end
    para "Cursor is #{app.cursor.inspect}"
  end
end
}}}

=== app.decorated » true or false ===

Decorations are the title bar and window resize controls. 

Returns true or false whether the window has decorations or not. See below
for the issues involved.

=== app.decorated = true or false ===

Warning: This is highly platform/theme specific.  DO NOT assume that if it works
for you, that it will work for anyone else. It won't work for everyone. OSX for example.
Combined with fullscreem - you are asking for trouble. Think twice or thrice.

Set window decorations. `true` will display titlebar, and resize buttons and `false` will hide them.

=== app.fullscreen » boolean ===

This returns true or false if your script is running in full screen mode

=== app.fullscreen = Boolea) ===

Set fullscreen to true or false. If you do this, you should provide a method
for turning it off. There's nothing more annoying that than a full screen app
that the user can't figure out how to quit and get back to normal. 

:fullscreen => true is also a style you can set for Shoes.app.

=== app.id » string ===

Returns a unique string for the app (window). This is different from name or title
which are not unique. Used internally. 

=== app.monitor » integer ===

Returns the small integer for the monitor (screen) the app is on. For systems with
only one monitor this will be 0. See the Advanced section
of this manual for Settings and Monitor.

=== app.monitor = integer ===

Moves the app (window) to the <integer> monitor. See the Advanced section
of this manual for Settings and Monitor.

=== app.name » string ===
Returns the title string for the App. Usually the string in the window's title bar.

=== app.name = String ===

Sets the title string of the current window. See Advanced/Settings or
app.set_window_title below to make the title string apply to new windows. 

=== app.location » shoes-url ===

Returns the Shoes url. Be careful. It's a shoes-url so it might not be what
you think.

=== app.resize width, height » boolean ===

Change the size of the window. You don't want to increase beyond your or
your users screen size - That could be a problem (crash?).  Also it can misbehave if 
you shrink it smaller than the original creation size. Always returns True 
but there is no error checking. Use cautiously.

=== app.started? » boolean ===

Is the app completely initiailized? 

=== app.width » a number ===

Returns the current width.

=== app.height » a number ===

Returns the current height. Perhaps you need it and the width after going fullscreen 
to setup your game to the size availavble. 

=== app.opacity » a float number ===

Returns a float number of the current window opacity. The default opacity is `1.0` 
where you see the window without transparency. An opacity of `0.0` is fully transparent window.

=== app.opacity = a float number ===

Set the window opacity with a float number. A fully transparent window has an opacity of `0.0` 
whereas a fully visible window has an opacity of `1.0`.

{{{
Shoes.app do
   @b = banner "Opacity\n"

   slider fraction: 1.0 do |n|
      app.opacity = n.fraction
      @b.text = "Opacity %.2f\n" % n.fraction
   end
end
}}}

=== app.slot » Array ===

For Advanced users: 

When you want to manage slots and elements from another Shoes.app window you need to
gets it's app and then get it's slots.contents and then you can poke around in in the 
stacks and flows and elements. 

This is the preferred method for getting an array of stacks and flows for the windows
that Shoes.APPS[] knows about.  

For example you have two windows (apps) and want to append a para to all but a specific window (app)

{{{
 #!ruby
 Shoes.app title: "Controller" do
   $other_win =  window title: "Slave" do
     stack { para "First"} 
   end
   stack do
     button "Append" do
       Shoes.APPS.each do |ap| 
         ap.slot.contents[0].instance_exec () {para "gotcha"} if ap == $other_win
       end
     end
   end
 end
}}}

There is much more to discover for advanced users on this topic. See IRB in this manual
and at the wiki.

=== app.set_window_icon_path(pathname) ===

This sets the icon in the title bar (and the dock or taskbar of your OS)
for this window and any others you create from this script. It replaces the little Shoes federales icon.
If you need this, do it for every app.  Depending on your OS, theme and desktop settings,
the icon may not be displayed at all.

See Advanced->Settings for additional possibilies.

{{{
 #!ruby
 Shoes.app :title => "I'm Shoes" do
    button "feeling blue" do
      Shoes.APPS.each {|a| a.set_window_icon_path("#{DIR}/static/shoes-icon-blue.png") }
      confirm "did all the Shoes icons change? "
    end
 end
}}}
The icon should be a 128x128 png. Or 256x256 png. 512x512 also works.

=== app.set_window_title(string) ===

This sets the string in the current title bar like name = does but also the default title
every new window you might create including the alert, ask and confirm dialogs.  What
it does not do is change the title of other existing windows. To be 

Note: the :title style setting only effects one window. This effects all ```NEW``` windows. 

If you need this, loop through all the Apps.

{{{
#!ruby
Shoes.app :title => "I'm Shoes" do
   button "change title" do
     Shoes.APPS.each {|a| a.set_window_title("No Shoes Here") }
     confirm "did the title change to No Shoes Here"
   end
end
}}}

Notice how the title is very sticky. 

== Svghandle ==

An svghandle is a non visual place holder into a svg (xml) file. Like an sqlite
query handle is a temporary place inside the database. Every Svg
widget has a handle (perhaps created by default).  You can do some manipulations
and creation of svghandles without an onscreen widget.

Many people can go merrily along their way without creating or manipulating
svghandles.  But, if you want to or need to - you can create with them by calling 'app.svghandle'
before creating any SVG widgets with them. Due to a lovely feature of Shoes
you do need parens () around the {hash args}. Please examine the samples/good-cardflip.rb 
to see how to use svghandles.

=== app.svghandle ({hash args})» svghandle ===

Returns an object of SvgHandle class. 

First we'll discuss the hash args which must be combined in one call. Then we'll show the methods
you can call on a svghandle.

Yes, parenthesis are required around the hash . Yes it is ugly.

=== app.svhandle ( {filename: path} ) ===

path is the pathname to an .svg file. If you are going to create multiple svghandles
from one file (a deck of cards for example) then you really should read it
into a ruby string and use the contents: below instead of reading the file
multiple times.

=== app.svhandle ( {contents: xmlstring} ) ===

Creates an svghandle from xmlstring. More useful when you provide a group.

=== app.svghandle( {group: string} ) ===

Creates an svghandle for the given group name (the string must start with a '#')

=== app.svghandle( {aspect: boolean or float} ) ===

The aspect can be 'true` which is the the default. false has the effect
of streching or shrinking it to the size of the Svg widget it will be shown
in and float will show it in the given w/h ratio. 

=== svghandle.width » a number ===

Returns the internal svg handle (group?) width. Not very useful. 

=== svghandle.height » a number ===

Returns the internal svg handle (group?) height. Not very useful.

=== svghandle.group? string » boolean ===

Returns true or false (nil) if the svghandle has a group matching the string
which starts with '#'
»

== Chart_series ==

This an object that you can explicitly create (or subclass if needed). It describes
a group of data (series) to be drawn in a plot.

=== chart_series {options} ===

Returns a chart_series object you can add to a plot. The options are exactly identical
to those you give for plot.add {options}. 

For the advanced explorer, you can do some
fun stuff if you work with explict chart_series object(s). Most of the options you set when adding
a hash of options can be modifed. Perhaps you have new data to add to the plot widget or you want to 
change the color based on the new data arriving or change the min/max . We have getters and setters to do that. 

It's not sub second real time graphing - computers vary but every 1 or 2 second is not unresonable if your willing to 
put that load on your box (or your user's boxen). I suggest you stick to the coarse Shoe aninmate or every methods
(much slower) before you go wild and deep into Ruby threading. If you ever think you need
to change a threads priority, stop digging that hole deeper and climb out for a rethink.

One other thing to consider: Shoes does not clone or dup or unfreeze arrays or strings. Just reference.
If that makes no sense, just know that we told you so and there is nothing Shoes can do about it.

=== chart_series.values ===

Returns the entire values array. A mistake just waiting for a catalyst.

=== chart_series.value = <array> ===

Replace the series values with a new array. A mistake just waiting for a catalyst.

=== chart_series.labels ===

Returns the entire labels array. A mistake just waiting for a catalyst.

=== chart_series.labels = <array> ===

Replace the series labels with a new array. A mistake just waiting for a catalyst.

=== chart_series.at <integer> ===

Returns a two element array of [label[index], values[index]], of type [String, Number]

=== chart_series.get index ===

Same as .at . Returns a two element array of [label[index], values[index]]

=== chart_series.set <integer>, ["new string", new_number] ===

This has some meat. Chew carefully.  The <integer> could be an existing observation to change
or it could be s new observation to append, depending on the <integer> The <integer> is a Ruby 
0 based index into both the label and values arrays. You can append (expand the Ruby arrays)

If you have 7 entries (0..6), append at 7 (array.size) or face the nil's that plot may not handle.

It will be serious mistake to set [nil, newvalue] or ["newlabel", nil] and expect that Shoes will fix your nil. 
It will segfault, if you are lucky. 

== Event Streams ==

This a very arcane and specialized capabilty. Basically you can get low level
events like click or key press and chose to send the event to normal Shoes GUI
handlers. For example you could disable all button clicks in another window

It's documented at https://github.com/shoes/shoes3/wiki/event-streams 
[[https://github.com/shoes/shoes3/wiki/event-streams Shoes Wiki]] You will want to study
and play with the Test/events/* scripts so you'll need a git clone of Shoes.

Caution: it's incomplete - if you need something more then create an issue
at the Shoes3 github.

== Monitors ==

Shoes does know about multiple monitors and provides some ways you can
use them. Of course, your system has to have multiple monitors and as a good
author you'll want to check the users system before using them. 

See the Settings section of Advanced in this manual for more monitor
information. 

You can specify the monitor for a Shoes app (window) using the sytle
 `monitor: <int>` with the Shoes.app and/or window methods. 
 
 
You can get the monitor that a Window (app) is using with the `app.monitor`
method and you can move a window to a different monitor with `app.monitor = `
method

{{{
Shoes.app do
  para "This app is on monitor #{app.monitor}"
end
}}}

== Settings ==

Shoes has a Settings class that is populated at startup with some values
that are common to all Windows/Apps. The values in settings are created before
Shoes starts your script - even before Shoes starts it's own scripts.


You can supply a startup.yaml file with your application and Shoes will use those
instead of the normal defaults. This should interest those that want to create more 
polished applications that the simple Shoes defaults. Please see the wiki
for some additional hints. Most of these settings are to improve Merge packaging. 
Again, see the Wiki. 

=== Shoes.settings » object ===

Once you get the settings object then you check some things. Some you can
modify. 

=== settings.app_name » string ===

Returns the application name. By default this is "Shoes" and is used as the 
default to Winodws titles and dialog titles and a few other user visible places.

=== settings.app_name = string ===

Set the default application name. The string will be used where ever "Shoes"
would appear in the menus or titles. 

=== settings.icon_path » string ===

Returns the Icon_Path string from the startup.yaml. The icon is a png that
should be inside the Shoes (your) app. Default is "static/shoes-app-icon.png"

=== settings.icon_path  = path_string ===

When called this way it's behaves like `app.set_window_icon_path`

=== setting.theme » string ===

For Linux and Windows, you can include a Gtk3 theme name in the startup.yaml file,
field `Theme;` The theme must be included with Shoes (see Merge packaging) in a themes folder.
If given, it's checked and used before any theme choices in the user's diretory -
~/.shoes/themes/ or {APPDATA}/Local/Shoes/Themes, should the user have them.
On linux, the theme will override/merge with the theme chosen in your desktop window
manager. 

=== settings.extra1 » string ===

Returns the `Extra1` string from the startup.yaml. Up to the developer what
the string means or does.

=== settings.extra2 » string ===

Returns the `Extra2` string from the startup.yaml. Up to the developer what
the string means or does.

=== setting.use_menus » boolean ===

Returns the setting of the startup.yaml `Use_menus` entry. This will put
a small default menubar on every window (app)  in the application. If used, 
it overrides the individual `menus: ` value for app/windows creation. 

=== settings.monitor_count » integer ===

Returns the number of monitors attached to the system. There will always be
one (1) monitor.

=== settings.monitor_default » integer ===

Returns the default monitor number. This is the one with the dock or global
menus. What the number is depends on how the user setup his monitors. Note:
The user can also change his monitor setup so you need to be clever when using
multiple monitors in Shoes. 

=== settings.monitor_geometry(<index>) » integer ===

Returns the geometery of the monitor given the index. By definition this
is a user specific value and it's also platfrom dependent. It is not wise
to use the x,y values unless you are targeting have a very specific single plaform, single
use application. In particular, try not use the second monitor for full screen
pixel based drawing (games).

=== settings.mdi » boolean ===

A Linux and Windows Future. Not implemented yet. OSX already does this and
needs no setting. MDI is Multi-Mocument-Interface. When `MDI: true` is in the
startup.yaml file the the desktop window manager will send `open` requests to
a running Shoes app when the user double clicks on a file the desktop manager
believes your application will handle. Linux uses the registered `dbus` name,
See below.

May not be implemented. 

=== settings.rdomain » string ===

If an `Rdomain: <string>` entry is in the startup.yaml file then it will be used 
instead of `com.shoesrb` to form the dbus name. Your setting for `App_Name` will be used
as well. So the default dbus name would be com.rbshoes.shoes. If MDI is false then the 
process id (pid) in Linux is appended. That make the dbus name fairly unique 
(enough) that you can start multiple shoes apps without one of them grabbing open
requests from the desktop that don't belong to it.  When MDI is true,  you don't 
want a unique name.  This has effects for systray notifications. 

=== settings.dbus » string ===

Linux and Windows only. As described above, this returns the registered dbus
name for the process. Linux users might use that and a dbus gem to communicate with other
applications that support dbus. Many Linux application do talk to dbugs and in theory your,
Shoes application can too. In Theory.

For example
{{{
Shoes.app do
  stack do
    st = Shoes.settings
    para "You have #{st.monitor_count} monitors."
    para "The default monitor is #{st.monitor_default}"
    st.monitor_count.times do |mon|
      para "Monitor #{mon} => #{st.monitor_geometry mon}"
    end
  end
end
}}}

=== settings.wintmo » integer ===

Only usable for Windows and only until the problem is fixed. See next paragraph.
Returns the current setting.

=== settings.wintmo = integer ===

Only for the Windows platform. Integer is the number of milliseconds for the mainloop
timeout (tmo). This controls how frequently time is given to backgound Ruby
threads. The default value is 10 which is a good balance of responsiveness for things
like animating a progress bar with a download - download use threads. If you have a long
operation like a very large copy of a complex file tree operation that is run in another thread
then it may not get as much time as you want. In that case try setting the tmo to 2 or even 1. 

It Is Highly Recommended that you restore the value after your long threaded operation. It's meaning 
and operation may seem counter intuitive. You should only do this if you really have a long threaded 
background operation (aka minutes long). Lower values will reduce the GUI speed.  Setting to zero would be
a very silly thing to do, so don't do it. Don't pass in floating point numbers.

Generally speaking, don't use this call. There is no setting in the startup.yaml
file for this.

=== settings.display_backend » string ===

For Linux, this is the value from the startup.yaml `Display_Backend` field. It contains the
names , comma separated, of the backends. 'x11' is the default. Unless you
know better, this field should not be set and 'wayland' is the only value
that works. If you have a wayland backend. 


=== settings Image_Cache ===

The Image_Cache: setting in startup.yaml does not have a Settings class method. You
can use the app.methods to get or change the value. The only value is  `Image_Cache: false`
to turn off the default.

=== settings OSX_Menu_Trim ===

This only exists in startup.yaml. There is no method to query the setting.
`OSX_Menu_Trim: true` in startup.yaml will not display the Shoes entries of
Open, Manual, Cobbler, Package and Profile" in the global menubar for OSX. This
might be useful when your packaged app doesn't want to to show all that could be
done.

== Terminal ==

Sometimes you want a logging window or even a window you can read keystrokes
from like an old school terminal. Shoes does have one. It's not very clever and
most people don't need it. Still, it has its uses.  The name changed in Shoes 3.3.2
to avoid confusion with all the existing uses of the word 'console' which usually
mean the log window (alt-/). 

Windows users can't use any of the tailoring options (they are silently ignored) so 
it's kind of cross platform and Windows does create a new 'console' and it
works within the limitations of MSFT's definition of a terminal. 

=== Shoes::show_console ===

That is the old (deprecated) way. It just calls Shoes.terminal with defaults.

=== Shoes.terminal {hash args} » nothing useful ===

Will bring up a new window that hooks stdin, stdout and stderr 
so it displays that output in the new window. This is a very brutal thing to do to the
perfectly happy C `printf()` and Ruby `puts` that don't normally display. 

The terminal window cannot be controlled by other Shoes method calls other than its
creation. There can be only one terminal because there is only one stdout, stderr, and 
stdin. 

Note: Terminals are not cross platform so what works on Linux may not work on 
Windows.  Windows is pretty dumb about consoles although I've heard Win 10
is much better.

Windows also behaves differently if you launch your Shoes script that calls Shoes.terminal
from the commandline - it uses that launch 'console' for display. If you launch a Shoes script
that calls Shoes.terminal from the menus/shortcuts then it will create a 
new dos console window. It's not really a problem that needs solving.

You can modify what is printed on the Shoes.terminal by embedding escape
sequences in the string you write to stdout or stderr. Shoes Linux and Shoes OSX
pretend to be xterm and xterm-256color devices and support a subset of color and 
character highlighting. Mostly to accomodate gems like test/unit. Windows is
not an xterm so those escape sequence will fail unless the end user has installed
one of those ANSI.dll things or Windows escape sequences are sent from the 
script or gem. NOT Something Shoes can fix. 

Those optional hash args to configure the terminal are described below.
They have to be combined into one hash arg for the one any only call you 
can make. You can call Shoes.terminal as many times as you like but only 
the first call sticks.

Note: on Shoes/OSX ruby's stdout.tty? may return nil depending on lauch method. 
Your gem (eg" test/unit) may need additional arguments {use_color: true}. Another
problem Shoes can fix.

=== Shoes.terminal {title: "string"} ===

defaults to "Shoes Terminal"

=== Shoes.terminal {columns: integer, rows: integer} ===

number of characters across and lines down. 80 x 24 is the default.

=== Shoes.terminal {fontsize: integer} ===

default is 10 for Linux and 12 for OSX. Point size.

=== Shoes.terminal {fg: "color", bg: "color"} ===

default is "black" text foreground (fg) on a "white" background (bg).

They do have to be strings. Although Linux has a long list of color names available, OSX only
has "black", "red", "green", "brown", "blue", "magenta","cyan","white" and
"yellow" 

As mentioned above none of these args matter to Windows.  Choose wisely
if you're going to set these colors. "Choose wisely" is kind of like " just don't". 

== CommandLine ==

For folks that like to use their terminal or Windows console to run Shoes there is
a pretty rich and useful set of options if you know where the Shoes program is. Where
it is actually a bit tricky so we may need to create an command for it which we call
`cshoes` 

{{{ 
$ cshoes -h
Usage: shoes [options] (app.rb or app.shy)
    -d, --debug                      Debug Shoes script
    -m, --manual                     Open the built-in manual.
    -w, --console                    display console
        --old-package                (Obsolete) Package a Shoes app for Windows, OS X and Linux.
    -c, --cobbler                    Maintain Shoes installation
    -p, --package                    Package Shoes App (new)
    -g, --gem                        Passes commands to RubyGems.
        --manual-html DIRECTORY      Saves the manual to a directory as HTML.
        --install MODE SRC DEST      Installs a file.
        --nolayered                  No WS_EX_LAYERED style option.
    -v, --version                    Display the version info.
    -h, --help                       Show this message
}}}

You can't run that from this manual. Some of those command switches are
obvious.  Don't expect --manual-html, --install or --nolayered to work.

There is a another  option that can be really useful for some folks.
{{{ --ruby rubyargments }}} This one uses the ruby inside Shoes to execute the 
`rubyargments` One of those arguments would be a script to execute with 
Shoes ruby. One can package apps this way. See the wiki for details.

Likewise -g manipulates gems inside the Shoes location. `-g env` for example or
`-g install myoddball-1.0`. Be careful - with great power comes great responsibility.


=== cshoes.exe (Windows) ===

Shoes on Windows has shoes.exe and cshoes.exe. If you want to use the Windows
Console for development or testing, please use cshoes.exe.

=== ./cshoes (OSX) ===

Life is not so easy on OSX. You have to use Maintain Shoes (cobbler) to create
a bash script that almost does what you want. 

=== cshoes (Linux) ===

Linux doesn't have a ./cshoes but you can create one if you're willing to
modify .bashrc/.bash_profile or what ever shell you're using. For example

`alias cshoes='~/.shoes/walkabout/shoes'` 


== Structuring ==

Using muliple ruby/shoes files to build an application is one way to group
code.

=== bindings and apps ===

=== url and visit ===

This is a mostly unknown way to structure a larger Shoes application. Lets say you
want three windows, a startup window, a data entry window and a help window. 
You subclass Shoes and use the url command to define the window names.
{{{
class MyApp < Shoes
	url "/", :setupscreen
	url "/entry", :entryscreen
	url "/help", :helpscreen
  
  def setupscreen
    stack do 
      para "Welcome to My Demo app"
      flow do
        button "entry" do visit '/entry'end
        button "help" do visit '/help' end
      end
    end
  end
  
  def entryscreen
    stack do 
      para "Entry Screen - whats your secret?"
      @the_secret = edit_line text: "Secret"
      flow do
        button "home" do visit '/'end
        button "help" do visit '/help' end
      end
    end
  end
  
  def helpscreen
     stack do 
      para "This page describes MyApp, a very demo for structuring a Shoes application "
      flow do
        button "entry" do visit '/entry'end
        button "home" do visit '/' end
      end
    end end
end
Shoes.app :width => 400, :height => 300, :margin => 5
}}}

That one you can run from the manual. It's also in samples/expert-url.rb

Is the @the_secret.text available in the other screens? No? How would you
find it? What if each screen did a `require "./helper_methods"` or something
that added methods to Module.Shoes ? 

There's no `one` proper way that I know of and probably six ways to Sunday to do it.

There is a limit on how far you are willing to push Shoes when you start down this path.

Remember to have fun!

= Menus =

Shoes applications can have menus if you ask for them. They are not enabled
by default because older Shoes code doesn't have them. 

There are limitations to the menu scheme. We don't do sub-menus. Images/icons or font 
setting are not supported. OSX menubar is global and Linux/Windows is one menubar
per Window. Be thoughtful if want to support menus on all platforms - you have some work 
to do.  

You enable menus by using the `menus: true` style with `Shoes.app` or `window`
method. You can also enable it with the settings file - See Advanced->Settings

== menubar ==

You need to get the menubar object before you can add menus to it. 

=== menubar ===

This returns a menubar. On OSX there is only one for all Windows/Apps
On Linux and Windows you get one menubar per Window (app)

=== menubar.menus » array  ===

Returns an array of `menu` objects.

=== menubar[index] » menu object ===

Index is a integer starting with 0. Index can also be a String which matches
a menu title. The `Shoes` menu (index 0) is special. You can't delete it from the
menubaror move it but you can manipulate the items in it. The Shoes name can be changed via a settings
file - see Advanced section of this manual

=== menubar << menu » nothing useful ===

Appends the menu to the menubar.

=== menubar.append menu » nothing useful ===

Appends the menu to the menubar.

=== menubar.insert menu, pos » nothing useful ===

Insert the `menu` in front of the menu at `pos` in the menubar. Pos may be an integer or the title of
of an existing menu. You can't insert before 0 aka "Shoes".

=== menubar.remove pos » nothing useful ===

Removes the menu from the menubar. Pos is an integer of the string title of
an existing menu. You can't remove 0 aka "Shoes"

== menu ==

Menus are the drop down list of menuitems. A menu has a position in the menubar and 
a title. You add menuitems to it.

=== menu title » menu ===

Creates a menu with the given title string. 

=== menu.title » string ===

Returns the title string of the `menu`

=== menu.items » array ===

Returns an array of menuitems attached to the menu.

=== menu[index] > menuitem ===

Returns the menuitem at index. Index is an integer number starting at 0
or it could be a String that matches a menuitem title. 

=== menu << menuitem ===

Append menuitem to menu

=== menu.append menuitem ===

Append menuitem to menu

=== menu.insert menuitem, pos ===

Insert menuitem before the pos item - zero would move everything down for
example. Pos can be an integer or the matching title string. You can insert  
or append to the Shoes menu. 

=== menu.remove pos ===

Remove the menuitem from the menu. Pos is an integer starting at 0 or
a matching title string.

== menuitem ==

Menuitems have a title, an optional accelerator key like control_o and they
have a block (or proc) of Shoes code to run when selected. 

=== menuitem title, {key hash}, block » menuitem ===

Creates a menuitem with the title. The key hash and block is optional, you can set
them later if need be. The key is used to activeate the block. The block behaves a 
lot like a button. A lot like a button. 

The key is a string like "control_o" or "alt_j". The can be combined with `shift_`. 
You COULD say "shift_ctl_alt_k" if that made sense for the platform. Shoes does not
prevent you from creating modifiers that won't work.  On OSX, the `control_` will be mapped to
the Apple command ⌘ key, not the control key on Mac keyboards.  
Use control_ and shift_control_ for portability. 

Note: If the title starts with three hyphens "--- this" then the menuitem becomes
a separator which does not have a block or accept an acclerator key string

=== menuitem.title » string ===

Returns the title string of the menuitem.

=== menuitem.title = string ===

Changes the title to `string`

=== menuitem.enable = boolean ===

Enables or disables the menuitem.  By default menuitems are created enabled.
You'll have to enable=false later.

=== menuitem.block = proc ===

You can set or change the block associated with the menuitem. You can change
the block on a menuitem is the Shoes menu, if you wanted to say, override the Quit item.
